head	1.1;
access;
symbols;
locks
	kyledewey:1.1; strict;
comment	@# @;


1.1
date	2010.06.18.20.56.16;	author kyledewey;	state Exp;
branches;
next	;


desc
@Wrapper around scaladoc that understands tha package hierarchy.
@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w

#
# scaladoc.pl
#
# Version:
#     $Id$
#
# Revisions:
#      $Log$
#
#

# Runs scaladoc on all the files that have been set to be part of sentinel
# This is needed as scaladoc is not as robust as javadoc
#
# Author: Kyle Dewey

use strict;

# begin constants
my $JAVA_DEV_ROOT = $ENV{ 'JAVA_DEV_ROOT' };
my $SOURCE_DIR = "$JAVA_DEV_ROOT/src";
my $DOC_DIR = "$JAVA_DEV_ROOT/docs";
my $WINDOW_TITLE = 'Error Sentinel API';
my $DOC_TITLE = 'Sentinel API';
my $HEADER = $DOC_TITLE;
my $SCALADOC = 'scaladoc';
my $SCALADOC_OPTIONS = "-d \"$DOC_DIR\" -sourcepath \"$SOURCE_DIR\" " .
    "-windowtitle \"$WINDOW_TITLE\" -doctitle \"$DOC_TITLE\"";
# end constants

# begin global variables
my %sourceFiles; # files that contain source information
# end global variables

# begin function prototypes
sub processChildDir( $ ); # needed due to recursion
# end function prototypes

# determines if the given file is a makefile
sub isMakefile( $ ) {
    my $file = shift();
    my $retval = undef;
    if ( $file eq 'Makefile' ||
	 $file eq 'makefile' ) {
	$retval = 1;
    }
    return $retval;
}

# parses a line that is expected to be a continuation of
# a multiline macro
# returns the data from the line, "" if this is just a blank
# line, and undef if this isn't a data line
sub parseDataLine( $ ) {
    my $line = shift();
    my $retval = "";

    if ( $line =~ /^\t([a-zA-z0-9\.]+)/ ) {
	$retval = $1;
    } elsif ( $line ne "" &&
	      $line =~ /^[^\t]/ ) {
	$retval = undef;
    }

    return $retval;
}

# given a Makefile, it will parse a multi-line macro
# Takes the following params:
# -The macro name
# -The path to the makefile containing package information
# Returns an array of all the packages in the makefile
sub getFromMacro( $$ ) {
    my ( $macroName,
	 $fileName ) = @@_;
    my @@retval;
    my $inMacro = undef;
    open( INPUT, "<$fileName" ) or die "Could not open $fileName: $!";
    
    while( my $line = <INPUT> ) {
	chomp( $line );
	if ( !$inMacro ) {
	    if ( $line =~ /^$macroName/ ) {
		$inMacro = 1;
	    }
	} else {
	    my $toPush = parseDataLine( $line );
	    if ( !defined( $toPush ) ) {
		last;
	    } elsif ( $toPush ne "" ) {
		push( @@retval, $toPush );
	    }
	}
    }

    close( INPUT );
    return @@retval;
}

# parses a makefile containing package information
# Takes the following params:
# -The path to the makefile
# returns all the packages in the makefile
sub getPackages( $ ) {
    my $fileName = shift();
    return getFromMacro( "PACKAGES",
			 $fileName );
}

# parses a makefile containing source file information
# Takes the following params:
# -The path to the makefile
# returns all the source files in the makefile
sub getSources( $ ) {
    my $fileName = shift();
    return getFromMacro( "SOURCE",
			 $fileName );
}

# given the name of a package, converts it to a path
# assumes that the package hierarchy matches up with the
# directory hierarchy
sub packageToPath( $ ) {
    my $pack = shift();
    $pack =~ s/\./\//g;
    return $pack;
}

# given a directory underneath the base directory, will
# recursivley process makefiles
sub processChildDir( $ ) {
    my $path = shift();
    opendir( DIRHANDLE, $path );
    my @@files = readdir( DIRHANDLE );
    closedir( DIRHANDLE );

    foreach my $file ( @@files ) {
	if ( $file eq '.' ||
	     $file eq '..' ) {
	    next;
	}
	if ( isMakefile( $file ) ) {
	    foreach my $source ( getSources( "$path/$file" ) ) {
		$sourceFiles{ "\"$path/$source\"" } = 1;
	    }
	} elsif ( -d $file ) {
	    processChildDir( "$path/$file" );
	}
    }
}

# given a base directory, will recursively process makefiles
# so that @@sourceFiles ends up containing all source files
# in the project
sub processBaseDir( $ ) {
    my $path = shift();
    my $makefile = undef;
    opendir( DIRHANDLE, $path );
    while( my $file = readdir( DIRHANDLE ) ) {
	if ( $file eq '.' ||
	     $file eq '..' ) {
	    next;
	}
	if ( isMakefile( $file ) ) {
	    $makefile = $file;
	    last;
	}
    }
    closedir( DIRHANDLE );
    if ( defined( $makefile ) ) {
	foreach my $pack ( getPackages( "$path/$makefile" ) ) {
	    processChildDir( $path . '/src/' . packageToPath( $pack ) );
	}
    }
}

# BEGIN MAIN PROGRAM CODE
my $baseDir = shift() || '.';
processBaseDir( $baseDir );
if ( scalar( keys( %sourceFiles ) ) > 0 ) {
    system( "$SCALADOC $SCALADOC_OPTIONS " . 
	    join( ' ', keys( %sourceFiles ) ) );
}

@
