head	1.7;
access;
symbols;
locks
	kyledewey:1.7; strict;
comment	@# @;


1.7
date	2011.06.18.03.28.47;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2011.03.27.14.04.37;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.20.22.54.19;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.20.17.25.38;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.18.19.37.06;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.16.01.00.30;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.15.17.56.41;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains code for creating and manipulating
parse trees.
@


1.7
log
@Added support for optimizations.
@
text
@/*
 * ParseTree.scala
 *
 * Version:
 *     $Id: ParseTree.scala,v 1.6 2011/03/27 14:04:37 kyledewey Exp $
 *
 * Revisions:
 *      $Log: ParseTree.scala,v $
 *      Revision 1.6  2011/03/27 14:04:37  kyledewey
 *      getChildren().map changed to getChildren().flatMap
 *
 *      Revision 1.5  2010/06/20 22:54:19  kyledewey
 *      Made factory an accessable value in InternalNode.
 *
 *      Revision 1.4  2010/06/20 17:25:38  kyledewey
 *      Moved ParseNode and ParseTreeFactory to Factory.scala.
 *
 *      Revision 1.3  2010/06/18 19:37:06  kyledewey
 *      Made factories take a name and description.
 *
 *      Revision 1.2  2010/06/16 01:00:30  kyledewey
 *      Made it so getValue() in ParseNode returns a
 *      Seq in order to account for arrays.
 *
 *      Revision 1.1  2010/06/15 17:56:41  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model

/*
 * Note that ParseNode is defined in Factory.scala.  This is needed
 * since there is a factory that creates instances via ParseNodes.
 */

/**
 * A terminal node containing a parameter.
 * @@param name The name of the node
 * @@param item The item to store
 * @@author Kyle Dewey
 */
class TerminalNode( name: String, val item: Param ) 
extends ParseNode( name ) {
  private val retval = new NamedParam( name, item )

  /**
   * Gets the value of the terminal node
   * @@param params Parameters to the node (ignored)
   * @@return the value
   */
  override def getValue( params: Seq[ NamedParam ] ) =
    Seq( retval )
}

/**
 * A node that is to be used as a variable.  This means a
 * variable in the tree, NOT a Variable.  Whereas a Variable
 * refers specifically to a value in the spreadsheet, this variable
 * can be any Param.
 * @@param name The name of the node
 * @@param mapsTo What parameter this node maps to in the given list of params
 * @@author Kyle Dewey
 */
class VariableNode( name: String, val mapsTo: String ) 
extends ParseNode( name ) {
  /**
   * Gets the variable this refers to.
   * @@param params The parameters which have been passed to the tree
   * @@return The param that we map to, with our name
   */
  override def getValue( params: Seq[ NamedParam ] ) = 
    params.filter( _.name == mapsTo ).map( _.rename( name ) )
}

/**
 * Holds helper routines for InternalNode.
 * @@author Kyle Dewey
 */
object InternalNode {
  /**
   * Given a matcher, returns either True or False, based on the matches().
   * @@param matcher The matcher
   * @@return Either True or False, depending on what the value of matches() is
   */
  def toMatcherConstant( matcher: Matcher ) =
    if ( matcher.matches ) new True()
    else new False()

  /**
   * Converts the given instance to a constant.
   * @@param instance The instance to convert
   * @@return The instance's value as a constant
   */
  def toConstant( instance: Instance ): Param =
    if ( instance.isInstanceOf[ Matcher ] ) {
      toMatcherConstant( instance.asInstanceOf[ Matcher ] )
    } else if ( instance.isInstanceOf[ Replacer ] ) {
      instance.asInstanceOf[ Replacer ].replace
    } else {
      instance
    }

  /**
   * Performs the purity optimization on the given param, if applicable.
   * This means that the given parameter is a pure instance that takes
   * constants as parameters.  In such a case, the return value will never
   * differ, and so it merely returns the return value.
   * @@param param The parameter to attempt this optimization on.
   * @@return Either the same parameter if the optimization wasn't possible,
   * or a new parameter that is equivalent if the optimization was possible
   */
  def purityOptimization( param: Param ) = {
    var retval = param
    if ( param.isInstanceOf[ Instance ] ) {
      val instance = param.asInstanceOf[ Instance ]
      if ( instance.isPure &&
	   instance.params.forall( _.param.isConstantType ) ) {
	retval = toConstant( instance )
      }
    }
    retval
  }
}

/**
 * An internal node representing either a matcher or replacer.
 * @@param name The name of the node
 * @@param factory A factory that can get the given matcher or replacer
 * @@author Kyle Dewey
 */
class InternalNode( name: String, val factory: InstanceFactory[ _ ] )
extends ParseNode( name ) {
  /**
   * Gets the instance that comes about through the evaulation of the given
   * parameters.
   * @@param params The parameters for children
   * @@param optimize true if we should optimize, else false
   * @@return The resulting instance.
   */
  def getInstance( params: Seq[ NamedParam ], optimize: Boolean ) = {
    val myParams =
      if ( optimize ) getChildren.flatMap( _.getOptimizedValue( params ) )
      else getChildren.flatMap( _.getValue( params ) )
    factory.instantiate( myParams, optimize ).asInstanceOf[ Param ]
  }
  
  /**
   * Gets the matcher or replacer.
   * All internal parameters to the matcher or replacer are initialized
   * via child nodes
   * @@param params The parameters to the tree (merely passed to children)
   * @@return The matcher or replacer
   */
  override def getValue( params: Seq[ NamedParam ] ) = 
    toReturnValue( getInstance( params, false ) )

  /**
   * Given the parameter to return, it will create a return value appropriate
   * for both <code>getValue</code> and <code>getOptimizedValue</code>
   * @@param param The parameter to return
   * @@return <code>Seq( new NamedParam( name, param ) )</code>
   */
  def toReturnValue( param: Param ) =
    Seq( new NamedParam( name, param ) )

  /**
   * Like <code>getValue</code>, only it performs optimizations.
   * Specifically, if the instance is pure, and its parameters are all
   * constants, then this simply returns a constant holding the instance's
   * value.
   * @@param params The parameters for the tree to pass to children.
   * @@return A parameter for this tree.
   */
  override def getOptimizedValue( params: Seq[ NamedParam ] ) = 
    toReturnValue( InternalNode.purityOptimization( getInstance( params, true ) ) )
}
@


1.6
log
@getChildren().map changed to getChildren().flatMap
@
text
@d5 1
a5 1
 *     $Id: ParseTree.scala,v 1.5 2010/06/20 22:54:19 kyledewey Exp $
d9 3
d78 50
d136 14
d156 10
a165 3
  override def getValue( params: Seq[ NamedParam ] ) = {
    val myParams = getChildren.flatMap( _.getValue( params ) )
    val param = factory.instantiate( myParams ).asInstanceOf[ Param ]
d167 11
a177 1
  }
@


1.5
log
@Made factory an accessable value in InternalNode.
@
text
@d5 1
a5 1
 *     $Id: ParseTree.scala,v 1.4 2010/06/20 17:25:38 kyledewey Exp kyledewey $
d9 3
d90 1
a90 1
    val myParams = getChildren.map( _.getValue( params ) ).flatMap( s => s )
@


1.4
log
@Moved ParseNode and ParseTreeFactory to Factory.scala.
@
text
@d5 1
a5 1
 *     $Id: ParseTree.scala,v 1.3 2010/06/18 19:37:06 kyledewey Exp kyledewey $
d9 3
d38 2
a39 2
class TerminalNode( name: String, 
		    val item: Param ) extends ParseNode( name ) {
d77 1
a77 2
class InternalNode( name: String, 
		    factory: InstanceFactory[ _ ] )
@


1.3
log
@Made factories take a name and description.
@
text
@d5 1
a5 1
 *     $Id: ParseTree.scala,v 1.2 2010/06/16 01:00:30 kyledewey Exp $
d9 3
d22 1
a22 3
package sentinel.model.parser

import sentinel.model._
d24 3
a26 5
/**
 * Represents a node in a parse tree.  Note that a node may
 * or may not be a terminal.
 * @@param name The name of the node
 * @@author Kyle Dewey
a27 29
abstract class ParseNode( val name: String ) {
  private var children: Seq[ ParseNode ] = Seq()

  /**
   * Attaches a child node to this node.
   * @@param node The child node
   */
  def attach( node: ParseNode ) =
    children = children ++ Seq( node )

  /**
   * Gets child nodes of this node.
   * @@return child nodes of this node
   */
  def getChildren() =
    children

  /**
   * Gets the value of this node.  Assumes that
   * the parse tree has been completely built.
   * Note that this returns a Seq in order to accomodate
   * given parameters which are arrays; under all other
   * conditions, it is guarenteed to return a Seq of
   * size 1.
   * @@param params Parameters to the tree
   * @@return The evaluated parameter
   */
  def getValue( params: Seq[ NamedParam ] ): Seq[ NamedParam ]
}
d35 2
a36 1
class TerminalNode( name: String, val item: Param ) extends ParseNode( name ) {
d75 1
a75 1
		    factory: ParameterizedObjectFactory[ _ ] )
a89 41

/**
 * A factory that creates objects based upon a parse tree.
 * @@param name The name of the factory.  Note that it prepends
 * "Parse Tree: " to the name
 * @@param desc A description of the factory
 * @@param neededParams The parameters that are valid for the tree
 * @@param tree The parse tree
 * @@author Kyle Dewey
 */
class ParseTreeFactory[ T ]( name: String,
			     desc: String,
			     neededParams: Map[ String, ParamInfo ],
			     val tree: ParseNode ) 
extends ParameterizedObjectFactory[ T ]( "Parse Tree: " + name,
					 desc,
					 neededParams ) {
  /**
   * Creates a new object based on the parse tree.
   * @@param params Parameters to the underlying object
   * @@return A new instance of the underlying object
   * @@throws ParameterizedInstantiationException If the params were ok but
   *         the object could not otherwise be instantiated
   */
  override def internalInstantiate( params: Seq[ NamedParam ] ) = {
    try {
      val root = tree.getValue( params )
      if ( root.size != 1 ) {
	throw new ParameterizedInstantiationException( "Tree returned array " +
						       "of params instead of " +
						       "a single param" )
      }
      root.first.param.asInstanceOf[ T ]
    } catch {
      case e: ParameterizedInstantiationException => throw e
      case e: Exception => 
	throw new ParameterizedInstantiationException( e )
    }
  }
}

@


1.2
log
@Made it so getValue() in ParseNode returns a
Seq in order to account for arrays.
@
text
@d5 1
a5 1
 *     $Id: ParseTree.scala,v 1.1 2010/06/15 17:56:41 kyledewey Exp kyledewey $
d9 4
d94 1
a94 1
    params.filter( _.name == mapsTo ).map( _.rename( name ) ).toSeq
d122 4
a126 1
 * @@param neededParams The parameters that are valid for the tree
d129 7
a135 3
class ParseTreeFactory[ T ]( val tree: ParseNode,
			     neededParams: Map[ String, ParamInfo ] ) 
extends ParameterizedObjectFactory[ T ]( neededParams ) {
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d45 4
d52 1
a52 1
  def getValue( params: Seq[ NamedParam ] ): NamedParam
d70 1
a70 1
    retval
d90 1
a90 1
    params.filter( _.name == mapsTo ).first.rename( name )
d110 3
a112 2
    val myParams = getChildren.map( _.getValue( params ) )
    new NamedParam( name, factory.instantiate( myParams ).asInstanceOf[ Param ]  )
d129 1
a129 1
   * @@throws ParameterizedInstantationException If the params were ok but
d134 7
a140 1
      tree.getValue( params ).param.asInstanceOf[ T ]
d142 1
a142 1
      case e: ParameterizedInstantationException => throw e
d144 1
a144 1
	throw new ParameterizedInstantationException( e )
@
