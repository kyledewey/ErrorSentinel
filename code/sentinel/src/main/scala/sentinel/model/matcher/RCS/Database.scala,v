head	1.3;
access;
symbols;
locks
	kyledewey:1.3; strict;
comment	@# @;


1.3
date	2011.06.08.04.25.53;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2011.06.04.07.42.44;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2011.06.01.16.42.27;	author kyledewey;	state Exp;
branches;
next	;


desc
@Allows for the connection to a relational database.
@


1.3
log
@Now conforms to the new Param interface.
@
text
@/*
 * Database.scala
 *
 * Version:
 *     $Id: Database.scala,v 1.2 2011/06/04 07:42:44 kyledewey Exp $
 *
 * Revisions:
 *      $Log: Database.scala,v $
 *      Revision 1.2  2011/06/04 07:42:44  kyledewey
 *      Refactored so that the very similar Database
 *      matcher and replacer share a common base class.
 *
 *      Revision 1.1  2011/06/01 16:42:27  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model.matcher

import java.sql._
import sentinel.model._
import sentinel.model.matcher.StringHelpers._

/**
 * Defines a database handle.  Note that handles are loaded lazily.
 * @@param name The name of the database handle
 * @@param driver The driver the handle is to use
 * @@param connectString The string used to connect to the database
 * @@param userName The name of the user to connect with.
 * @@param password The password to connect with.
 * @@author Kyle Dewey
 */
class DatabaseHandle( val name: String, 
		      val driver: String, 
		      val connectString: String,
		      val userName: Option[ String ],
		      val password: Option[ String ] ) {
  lazy val connection = loadHandle()

  /**
   * Loads in the database handle.
   * @@return The connection
   * @@throws Exception If something goes wrong
   */
  def loadHandle() = {
    Class.forName( driver )
    if ( userName.isDefined ||
	 password.isDefined ) {
      DriverManager.getConnection( connectString, 
				   userName.getOrElse( "" ),
				   password.getOrElse( "" ) )
    } else {
      DriverManager.getConnection( connectString )
    }
  }

  /**
   * Sets the given statement to use the given params.
   * Note that for all parameters, setObject is used without typing information.
   * @@param statement The statement
   * @@param params The parameters for the statement.
   * @@throws Exception If an exception was thrown while processing it
   */
  def setQueryParams( statement: PreparedStatement, params: Seq[ String ] ) {
    1.to( params.size ).foreach( paramNum =>
      statement.setObject( paramNum, 
			   params( paramNum - 1 ) ) )
  }

  /**
   * Runs the given query with the given parameters.
   * @@param query The query to run
   * @@param params The parameters for the query
   * @@return The first item in the first row of the query, or None if there
   * were no results
   * @@throws Exception If an exception was thrown upon trying to
   * run the query
   */
  def runQuery( query: String, params: Seq[ String ] ) = {
    var statement: PreparedStatement = null
    var toThrow: Exception = null
    var retval: Option[ String ] = None

    try {
      statement = connection.prepareStatement( query )
      setQueryParams( statement, params )
      val results = statement.executeQuery
      if ( results.next ) {
	val asObject = results.getObject( 1 )
	val asString =
	  if ( asObject == null ) "" else asObject.toString
	retval = Some( asString )
      }
    } finally {
      if ( statement != null ) {
	statement.close()
      }
    }

    retval
  }
}

/**
 * Contains routines for parsing in the database handle file.
 * Note that handles are loaded lazily.
 * @@author Kyle Dewey
 */
object DatabaseHandleParser {
  import scala.xml._

  val DEFAULT_FILE_NAME = ".Sentinel_DBHandles.xml"
  val DEFAULT_FILE_PATH = 
    System.getProperty( "user.home" ) + "/" + DEFAULT_FILE_NAME

  def getNodes( base: Node, tag: String ) =
    XMLHelpers.getNodes( base, tag, MatchException( _ ) )

  def getText( base: Node, tag: String ) =
    XMLHelpers.getText( base, tag, MatchException( _ ) )

  /**
   * Parses in the given database handle node.
   * @@param node The node holding the database handle information
   * @@return A database handle for the node
   */
  def parseDBHandle( node: Node ) = 
    new DatabaseHandle( getText( node, "Name" ),
		        getText( node, "Driver" ),
		        getText( node, "DatabaseConnect" ),
		        XMLHelpers.getOptionalText( node, "UserName" ),
		        XMLHelpers.getOptionalText( node, "Password" ) )
    
  /**
   * Parses in database handles from the given XML node.
   * @@param node The node containing database handles.
   * @@return Database handles, in the same order as seen in the file
   */
  def parseDBHandles( node: Node ): Seq[ DatabaseHandle ] =
    ( node \ "DatabaseHandle" ).map( parseDBHandle( _ ) )

  /**
   * Parses in database handles from the given file.
   * @@param path The file's path to parse them in from
   * @@throw MatchException If the file is malformed, doesn't exist, or could
   * not be read for whatever reason
   */
  def parseDBHandles( path: String ): Map[ String, DatabaseHandle ] = {
    try {
      Map() ++ parseDBHandles( XML.loadFile( path ) ).map( handle =>
	Pair( handle.name, handle ) )
    } catch {
      case e: MatchException => throw e
      case e: Exception => throw new MatchException( e.getMessage )
    }
  }

  /**
   * Parses in database handles from <code>DEFAULT_FILE_PATH</code>.
   * @@throw MatchException If the file is malformed, doesn't exist, or could
   * not be read for whatever reason
   */
  def parseDBHandles(): Map[ String, DatabaseHandle ] =
    parseDBHandles( DEFAULT_FILE_PATH )
}

/**
 * Manages open database connections.
 * It would be overcomplicated to pass all the parameters needed to connect
 * to a database every time a database matcher would be used, so parameters
 * are stored elsewhere.
 * @@author Kyle Dewey
 */
object DatabaseHandleManager {
  lazy val handle = 
    DatabaseHandleParser.parseDBHandles()
}

/**
 * Base class for database matchers and replacers.
 * Works like a normal instance.  Doesn't extend instance to prevent
 * it from being used as an instance.
 * @@param className The name of the class
 * @@param params Params to the matcher<ul>
 * <li>"handle": The name of the database handle to use.  Must be defined
 * in another file.  See <code>DatabaseHandleParser</code> for more
 * information.</li>
 * <li>"query": The parameterized query to use.  Uses question marks for
 * parameter positions, as is the typical parameterized SQL style.</li>
 * <li>"params": The parameters for the query.</li></ul>
 * @@author Kyle Dewey
 */
class Database( val className: String,
	        val params: Seq[ NamedParam ] ) {
  import sentinel.model.InstanceFactory._
  private val handle = param( "handle", params )
  private val query = param( "query", params )
  private val queryParams = 
    opAsArray( "params", params ).getOrElse( Seq[ Param ]() )
  
  /**
   * Gets the first column of the first row of a query.
   * @@return The first column of the first row of a query, or None
   * if the query returned no results.
   * @@throws Exception If an exception occurred while processing the query.
   */
  def runQuery() =
    DatabaseHandleManager.handle( handle.sentStringValue )
                         .runQuery( query.sentStringValue,
				    toStrings( queryParams ) )
}

/**
 * Matcher that utilizes a relational database.
 * If a given query with given query parameters returned a result,
 * then this is considered a match.  Otherwise it's considered
 * no match.
 * @@param className The name of the class
 * @@param params Params to the matcher<ul>
 * <li>"handle": The name of the database handle to use.  Must be defined
 * in another file.  See <code>DatabaseHandleParser</code> for more
 * information.</li>
 * <li>"query": The parameterized query to use.  Uses question marks for
 * parameter positions, as is the typical parameterized SQL style.</li>
 * <li>"params": The parameters for the query.</li></ul>
 * @@author Kyle Dewey
 */
class DatabaseMatcher( className: String, params : Seq[ NamedParam ] ) 
extends Database( className, params ) with Matcher {
  /**
   * Returns true if the database query with the given parameters
   * had a result.  Otherwise it returns false
   * @@return true if the query had results, else false
   * @@throws MatchException If there was any problem with processing
   * the query
   */
  override def matches() =
    try {
      runQuery.isDefined
    } catch {
      case e: Exception => throw new MatchException( e.toString )
    }
}
@


1.2
log
@Refactored so that the very similar Database
matcher and replacer share a common base class.
@
text
@d5 1
a5 1
 *     $Id: Database.scala,v 1.1 2011/06/01 16:42:27 kyledewey Exp $
d9 4
d23 1
d197 2
a198 2
  private val handle = param[ Data ]( "handle", params )
  private val query = param[ Data ]( "query", params )
d200 1
a200 1
    opAsArray[ Data ]( "params", params ).getOrElse( Seq[ Data ]() )
d209 3
a211 3
    DatabaseHandleManager.handle( handle.data )
                         .runQuery( query.data,
				    queryParams.map( _.data ) )
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d39 1
a39 1
   * @@throws MatchException If an exception was thrown upon trying to connect
d42 8
a49 12
    try {
      Class.forName( driver )
      if ( userName.isDefined ||
	   password.isDefined ) {
	DriverManager.getConnection( connectString, 
				     userName.getOrElse( "" ),
				     password.getOrElse( "" ) )
      } else {
	DriverManager.getConnection( connectString )
      }
    } catch {
      case e: Exception => throw new MatchException( e.getMessage )
d58 1
a58 1
   * @@throws MatchException If an exception was thrown while processing it
d61 3
a63 10
    try {
      1.to( params.size ).foreach( paramNum =>
	statement.setObject( paramNum, 
			     params( paramNum - 1 ) ) )
    } catch {
      case e: Predef.NoSuchElementException => 
	throw new MatchException( "One or more parameters could not produce " +
				  "a printable value" )
      case e: Exception => throw new MatchException( e.getMessage )
    }
d70 3
a72 2
   * @@return true if the query returned results, else false
   * @@throws MatchException If an exception was thrown upon trying to
d78 1
a78 1
    var retval = false
d83 6
a88 7
      retval = statement.executeQuery.next
    } catch {
      case e: MatchException => {
	toThrow = e
      }
      case e: Exception => {
	toThrow = new MatchException( e.getMessage )
a95 4
    if ( toThrow != null ) {
      throw toThrow
    }

d176 3
a178 4
 * Matcher that utilizes a relational database.
 * If a given query with given query parameters returned a result,
 * then this is considered a match.  Otherwise it's considered
 * no match.
d190 1
a190 1
	        val params: Seq[ NamedParam ] ) extends Matcher {
d198 29
d234 5
a238 3
    DatabaseHandleManager.handle( handle.data )
                         .runQuery( query.data,
				    queryParams.map( _.data ) )
@
