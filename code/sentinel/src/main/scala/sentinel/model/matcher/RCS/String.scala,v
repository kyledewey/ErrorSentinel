head	1.5;
access;
symbols;
locks
	kyledewey:1.5; strict;
comment	@# @;


1.5
date	2011.06.08.04.25.53;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.02.06.56.13;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.25.20.14.06;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.28.18.43.02;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.26.04.04.04;	author kyledewey;	state Exp;
branches;
next	;


desc
@Matchers that perform operations on strings.
@


1.5
log
@Now conforms to the new Param interface.
@
text
@/*
 * String.scala
 * 
 * Version:
 *     $Id: String.scala,v 1.4 2011/06/02 06:56:13 kyledewey Exp $
 *
 * Revisions:
 *      $Log: String.scala,v $
 *      Revision 1.4  2011/06/02 06:56:13  kyledewey
 *      Added code so that the regex is only recompiled
 *      when the regex string actually changes, as opposed
 *      to each time the function is called.
 *
 *      Revision 1.3  2011/05/25 20:14:06  kyledewey
 *      Made it so the class name is also taken as a parameter.
 *
 *      Revision 1.2  2010/06/28 18:43:02  kyledewey
 *      Fixed typo.
 *
 *      Revision 1.1  2010/06/26 04:04:04  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model.matcher

import sentinel.model._
import sentinel.model.InstanceFactory._

/**
 * Holds helper routines for String.
 * @@author Kyle Dewey
 */
object StringHelpers {
  def toStrings( params: Seq[ Param ] ) =
    params.map( _.sentStringValue )
}

import StringHelpers._

/**
 * Determines if all the given strings are the same as each other.
 * @@param className The name of the class
 * @@param params Params to the matcher
 * <ul><li>"strings": The strings to test for equality</li></ul>
 * @@author Kyle Dewey
 */
class StringEqual( val className: String,
		   val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )

  /**
   * Determines if all the given strings are equal to each other
   * @@return true if they are all equal, else false
   */
  override def matches() =
    Matcher.allEqual( toStrings( strings ) )
}

/**
 * Determines if all the given strings are different from each other.
 * @@param className The name of the class
 * @@param params Params to the matcher
 * <ul><li>"strings": The strings to test for non-equality</li></ul>
 * @@author Kyle Dewey
 */
class StringNotEqual( val className: String,
		      val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )

  /**
   * Determines if all the given strings are not equal to each other.
   * @@return true if they are all different, else false
   */
  override def matches() =
    Matcher.allDifferent( toStrings( strings ) )
}

/**
 * Determines if all the given strings are monotonically increasing.
 * In other words, something like 1 > 2 > 3
 * @@param className The name of the class
 * @@param Params params to the matcher
 * <ul><li>"strings": The strings to test</li></ul>
 * @@author Kyle Dewey
 */
class StringGreater( val className: String,
		     val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )

  /**
   * Determines if all the given strings are monotonically increasing
   * @@return true if they are increasing, else false
   */
  override def matches() =
    Matcher.allGreater( toStrings( strings ) )
}

/**
 * Determines if all the given strings are monotonically decreasing.
 * In other words, something like 1 > 2 > 3
 * @@param className The name of the class
 * @@param Params params to the matcher
 * <ul><li>"strings": The strings to test</li></ul>
 * @@author Kyle Dewey
 */
class StringLess( val className: String,
		  val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )

  /**
   * Determines if all the given strings are monotonically decreasing
   * @@return true if they are decreasing, else false
   */
  override def matches() =
    Matcher.allLess( toStrings( strings ) )
}

class StringLessOrEqual( val className: String,
			 val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )
  override def matches() =
    Matcher.allLessOrEqual( toStrings( strings ) )
}

class StringGreaterOrEqual( val className: String,
			    val params: Seq[ NamedParam ] ) extends Matcher {
  private val strings = asArray( "strings", params )
  override def matches() =
    Matcher.allGreaterOrEqual( toStrings( strings ) )
}

/**
 * Matches a string against a regular expression.
 * @@param className The name of the class
 * @@param params Params to the matcher
 * <ul><li>"string": The string to try to find a regex match in</li>
 * <li>"regex": The regular expression to try to find in the string</li></ul>
 * @@author Kyle Dewey
 */
class Regex( val className: String,
	     val params: Seq[ NamedParam ] ) extends Matcher {
  import java.util.regex.PatternSyntaxException
  import scala.util.matching.{ Regex => SRegex }
  private val string = param( "string", params )
  private val regexString = param( "regex", params )
  private var lastRegexString: Option[ String ] = None
  private var regex: Option[ SRegex ] = None

  /**
   * Determines if the string matches the regular expression.
   * @@return true if it matches the pattern, else false
   * @@throws MatchException If the regex string is invalid
   */
  override def matches() = {
    try {
      val currentRegexString = regexString.sentStringValue
      if ( lastRegexString.isEmpty ||
	   lastRegexString.get != currentRegexString ||
	   regex.isEmpty ) {
	lastRegexString = Some( currentRegexString )
	regex = Some( currentRegexString.r )
      }

      regex.get.findFirstIn( string.sentStringValue ).isDefined
    } catch {
      case e: PatternSyntaxException =>
	throw new MatchException( e.toString )
    }
  }
}
@


1.4
log
@Added code so that the regex is only recompiled
when the regex string actually changes, as opposed
to each time the function is called.
@
text
@d5 1
a5 1
 *     $Id: String.scala,v 1.3 2011/05/25 20:14:06 kyledewey Exp $
d9 5
d32 11
d51 1
a51 1
  private val strings = asArray[ SentString ]( "strings", params )
d58 1
a58 1
    Matcher.allEqual( strings )
d70 1
a70 1
  private val strings = asArray[ SentString ]( "strings", params )
d77 1
a77 1
    Matcher.allDifferent( strings )
d90 1
a90 1
  private val strings = asArray[ SentString ]( "strings", params )
d97 1
a97 1
    Matcher.allGreater( strings )
d110 1
a110 1
  private val strings = asArray[ SentString ]( "strings", params )
d117 1
a117 1
    Matcher.allLess( strings )
d122 1
a122 1
  private val strings = asArray[ SentString ]( "strings", params )
d124 1
a124 1
    Matcher.allLessOrEqual( strings )
d129 1
a129 1
  private val strings = asArray[ SentString ]( "strings", params )
d131 1
a131 1
    Matcher.allGreaterOrEqual( strings )
d146 2
a147 2
  private val string = param[ SentString ]( "string", params )
  private val regexString = param[ SentString ]( "regex", params )
d158 1
a158 1
      val currentRegexString = regexString.value
d166 1
a166 1
      regex.get.findFirstIn( string.value ).isDefined
d169 1
a169 1
	throw new MatchException( "Invalid regex string: " + e.getMessage )
@


1.3
log
@Made it so the class name is also taken as a parameter.
@
text
@d5 1
a5 1
 *     $Id: String.scala,v 1.2 2010/06/28 18:43:02 kyledewey Exp $
d9 3
d128 2
a129 1
  import java.util.regex._
d131 3
a133 1
  private val regex = param[ SentString ]( "regex", params )
d142 9
a150 1
      regex.value.r.findFirstIn( string.value ).isDefined
@


1.2
log
@Fixed typo.
@
text
@d5 1
a5 1
 *     $Id: String.scala,v 1.1 2010/06/26 04:04:04 kyledewey Exp $
d9 3
d25 1
d30 2
a31 1
class StringEqual( params: Seq[ NamedParam ] ) extends Matcher {
d44 1
d49 2
a50 1
class StringNotEqual( params: Seq[ NamedParam ] ) extends Matcher {
d64 1
d69 2
a70 1
class StringGreater( params: Seq[ NamedParam ] ) extends Matcher {
d84 1
d89 2
a90 1
class StringLess( params: Seq[ NamedParam ] ) extends Matcher {
d101 2
a102 1
class StringLessOrEqual( params: Seq[ NamedParam ] ) extends Matcher {
d108 2
a109 1
class StringGreaterOrEqual( params: Seq[ NamedParam ] ) extends Matcher {
d117 1
d123 2
a124 1
class Regex( params: Seq[ NamedParam ] ) extends Matcher {
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d111 1
a111 1
  private val string = param[ SentString ]( "strings", params )
@
