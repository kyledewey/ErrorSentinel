head	1.3;
access;
symbols;
locks
	kyledewey:1.3; strict;
comment	@# @;


1.3
date	2010.06.20.17.31.52;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.18.19.37.26;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.18.03.00.42;	author kyledewey;	state Exp;
branches;
next	;


desc
@Base class for anything that wants to write out the language.
@


1.3
log
@Now uses InstanceFactory[ _ ] instead of
Either[ MatcherFactory, ReplacerFactory ]
@
text
@/*
 * Writer.scala
 *
 * Version:
 *     $Id: Writer.scala,v 1.2 2010/06/18 19:37:26 kyledewey Exp kyledewey $
 *
 * Revisions:
 *      $Log: Writer.scala,v $
 *      Revision 1.2  2010/06/18 19:37:26  kyledewey
 *      Made factories take a name and description.
 *
 *      Revision 1.1  2010/06/18 03:00:42  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model.writer

import sentinel.model._

/**
 * Exception thrown when there was an error on writing out a class.
 * @@param message A message to show
 * @@author Kyle Dewey
 */
case class ClassWriteException( message: String ) 
     extends Exception( message ) {}

/**
 * Contains routines for writing classes to any given format.
 * @@param fileName The file to wirte to
 * @@author Kyle Dewey
 */
abstract class ClassWriter( val fileName: String ) {
  /**
   * Writes all of the given classes to the file.
   * Note that this will OVERWRITE any classes already existing
   * in the given file, and for that matter the entire contents
   * of the file.
   * @@param classes The classes to write out
   * @@throws ClassWriteException If it couldn't figure out how to
   *         write out a given class
   * @@throws IOException If an error occurred on writing
   */
  def writeClasses( classes: Seq[ InstanceFactory[ _ ] ] )
}
@


1.2
log
@Made factories take a name and description.
@
text
@d5 1
a5 1
 *     $Id: Writer.scala,v 1.1 2010/06/18 03:00:42 kyledewey Exp kyledewey $
d9 3
d20 1
a20 2
import sentinel.model.matcher._
import sentinel.model.replacer._
d23 2
a24 2
 * Contains helper routines of interest to classes which wish to
 * write out classes.
d27 2
a28 56
object ClassWriter {
  /**
   * Given a class, determines the type of the class, whether
   * or not it is a built in, and the name of the class if
   * it is a built in.
   * @@param theClass the class to get this information from
   * @@return -the name of the class
   *         -a description of the class
   *         -the type of the class (MATCHER_STRING, REPLACER_STRING),
   *         -whether or not the class is a built in,
   *         -the JVM class name of the class (None if it is not a built in)
   *         -the params the class takes
   */
  def getClassInfo( theClass: Either[ MatcherFactory, ReplacerFactory ] ) = {
    import ParamType._
    // TODO: user defined anything
    var name: String = null
    var desc: String = null
    var theType: String = null
    var builtIn: Boolean = false
    var JVMClassName: Option[ String ] = None
    var params: Map[ String, ParamInfo ] = null

    theClass match {
      case Left( theMatcher ) => {
	name = theMatcher.name
	desc = theMatcher.desc
	theType = MATCHER_STRING
	builtIn = theMatcher.isInstanceOf[ ReflectionMatcherFactory ]
	params = theMatcher.validParams
	if ( builtIn ) {
	  JVMClassName = Some( theMatcher.asInstanceOf[ ReflectionMatcherFactory ]
			                 .JVMClassName )
	}
      }
      case Right( theReplacer ) => {
	name = theReplacer.name
	desc = theReplacer.desc
	theType = REPLACER_STRING
	builtIn = theReplacer.isInstanceOf[ ReflectionReplacerFactory ]
	params = theReplacer.validParams
	if ( builtIn ) {
	  JVMClassName = Some( theReplacer.asInstanceOf[ ReflectionReplacerFactory ]
			                  .JVMClassName )
	}
      } 
    }

    ( name,
      desc,
      theType,
      builtIn,
      JVMClassName,
      params )
  }
}
d42 2
d46 1
a46 1
  def writeClasses( classes: Seq[ Either[ MatcherFactory, ReplacerFactory ] ] )
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d21 62
d93 1
a93 4
   * @@param classes The classes to write out.  Each element represents one
   *        class.  The first element is the name of the class, the
   *        second element is a description of the class, and the
   *        third element is the class itself.
d96 1
a96 4
  def writeClasses( classes: Seq[ ( String,
				    String,
				    Either[ MatcherFactory, 
					    ReplacerFactory ] ) ] ): Unit
a97 3



@
