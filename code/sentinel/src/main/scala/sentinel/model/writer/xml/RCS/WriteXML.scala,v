head	1.9;
access;
symbols;
locks
	kyledewey:1.9; strict;
comment	@# @;


1.9
date	2011.06.08.04.27.25;	author kyledewey;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.10.04.06.28;	author kyledewey;	state Exp;
branches;
next	1.7;

1.7
date	2011.02.12.02.50.47;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.11.05.52.47;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.25.03.20.25;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.20.22.54.50;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.20.17.32.39;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.18.19.37.35;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.18.03.00.12;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains routines for writing the language in XML.
@


1.9
log
@Conforms to the new interface for spreadsheet variables.
@
text
@/*
 * WriteXML.scala
 *
 * Version:
 *     $Id: WriteXML.scala,v 1.8 2011/04/10 04:06:28 kyledewey Exp $
 *
 * Revisions:
 *      $Log: WriteXML.scala,v $
 *      Revision 1.8  2011/04/10 04:06:28  kyledewey
 *      Append now works correctly.
 *
 *      Revision 1.7  2011/02/12 02:50:47  kyledewey
 *      Now uses SpreadsheetVariable instead of just Variable.
 *
 *      Revision 1.6  2010/07/11 05:52:47  kyledewey
 *      Formal parameters are no longer sorted upon being written
 *      out; this is mostly for show.
 *
 *      Revision 1.5  2010/06/25 03:20:25  kyledewey
 *      Refactored so that variables have types.
 *
 *      Revision 1.4  2010/06/20 22:54:50  kyledewey
 *      Now capable of writing out user-defined classes.
 *
 *      Revision 1.3  2010/06/20 17:32:39  kyledewey
 *      Now uses InstanceFactory[ _ ] instead of
 *      Either[ MatcherFactory, ReplacerFactory ].
 *
 *      Revision 1.2  2010/06/18 19:37:35  kyledewey
 *      Made factories take a name and description.
 *
 *      Revision 1.1  2010/06/18 03:00:12  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model.writer.xml

import sentinel.model._
import sentinel.model.writer._
import scala.xml._

/**
 * Contains helper routines for XMLWriter.
 * @@author Kyle Dewey
 */
object XMLWriter {
  // begin constants
  val WIDTH = java.lang.Integer.MAX_VALUE
  val INDENTATION = 2
  // constants

  /**
   * Given a constant, packages it as an XML node.
   * @@param name The name of the constant
   * @@param constant The constant to package
   * @@return The constant as an XML node
   */
  def constantToNode( name: String, constant: Param ) = {
    <ConstantParameter>
      <Name>{ name }</Name>
      <Type>{ ParamType.toString( constant.getType ) }</Type>
      <Value>{ constant.sentStringValue }</Value>
    </ConstantParameter>
  }

  /**
   * Given a variable, packages it as an XML node.
   * @@param name The name of the variable
   * @@param variable The variable to package
   * @@return The variable as an XML node
   */
  def variableToNode( name: String, variable: SpreadsheetVariable ) = {
    import Spreadsheet._
    <VariableParameter>
      <Name>{ name }</Name>
      <Type>{ ParamType.toString( variable.getType ) }</Type>
      <Sheet>{ variable.sheet.getOrElse( ANY_SHEET ) }</Sheet>
      <Row>{ variable.row.getOrElse( ANY_ROW ) }</Row>
      <Column>{ variable.column.getOrElse( ANY_COLUMN ) }</Column>
    </VariableParameter>
  }

  /**
   * Given a terminal node, packages it as either a constant or
   * a variable.
   * @@param node The terminal node
   * @@return The node as an XML node, either "ConstantParameter" or
   *         "VariableParameter"
   * @@throws ClassWriteException If the node was a terminal, but didn't
   *         map to either a constant or a variable
   */
  def terminalNodeToNode( node: TerminalNode ) = {
    node.item match {
      case item: SimpleVariable[ _ ] => constantToNode( node.name, node.item )
      case item: Constant[ _ ] => constantToNode( node.name, node.item )
      case item: SpreadsheetVariable => variableToNode( node.name, item )
      case _ =>
	throw new ClassWriteException( "Unknown terminal kind in terminal " +
				       "node.  Name: " + node.name + "; " +
				       "Type: " + 
				       ParamType.toString( node.item.getType ) )
    }
  }

  /**
   * Packages a VariableNode as an XML node.
   * @@param node The node to package
   * @@return The node as an XML node
   */
  def variableNodeToNode( node: VariableNode ) = {
    <GivenParameter>
      <Name>{ node.name }</Name>
      <MapsTo>{ node.mapsTo }</MapsTo>
    </GivenParameter>
  }

  /**
   * Packages an internal node as an XML node.
   * @@param node The node to package
   * @@return The node as an XML node
   */
  def internalNodeToNode( node: InternalNode ): Node = {
    <InstanceParameter>
    <Name>{ node.name }</Name>
    <Type>{ ParamType.toString( node.factory.instanceType ) }</Type>
    <ClassName>{ node.factory.name }</ClassName>
    <ActualParameters>
    { node.getChildren.map( actualParameterToNode( _ ) ) }
    </ActualParameters>
    </InstanceParameter>
  }

  /**
   * Packages the given node representing an actual parameter to
   * a factory as an XML node
   * @@param node The node to package
   * @@return The node as an XML node
   * @@throws ClassWriteException If a terminal node contained a non-terminal
   *         type, or if the node type is unknown
   */
  def actualParameterToNode( node: ParseNode ) = {
    node match {
      case node: TerminalNode => terminalNodeToNode( node )
      case node: VariableNode => variableNodeToNode( node )
      case node: InternalNode => internalNodeToNode( node )
      case _ =>
	throw new ClassWriteException( "Unknown parse node type with class: " +
				       node.getClass.getName )
    }
  }

  /**
   * Packages the parse tree structure of a class as a Structure node.
   * @@param root The root of the parse tree
   * @@return A Node encapsulating the parse tree structure
   */
  def parseTreeToNode( root: ParseNode ) = {
    <Structure>
    { actualParameterToNode( root ) }
    </Structure>
  }


  /**
   * Packages the given formal parameter as a node.
   * @@param param The formal parameter
   * @@return A Node encapsulating this parameter
   */
  def formalParamToNode( param: ParamInfo ) = {
    <FormalParameter>
    <Name>{ param.name }</Name>
    <Description>{ param.desc }</Description>
    <Type>{ ParamType.toString( param.paramType ) }</Type>
    <IsArray>{ param.isArray.toString }</IsArray>
    <IsRequired>{ param.isRequired.toString }</IsRequired>
    </FormalParameter>
  }
  
  /**
   * Packages the given formal parameters into nodes.
   * @@param params The formal parameters to package
   * @@return A node containing all formal parameters
   */
  def formalParamsToNode( params: Seq[ ParamInfo ] ) = {
    <FormalParameters>
    { params.map( formalParamToNode( _ ) ) }
    </FormalParameters>
  }

  /**
   * Packages the given class into a node.
   * @@param theClass The class itself
   * @@return The class, as a node
   * @@throws ClassWriteException If an error occurred on converting the
   * class to XML
   */
  def classToNode( theClass: InstanceFactory[ _ ] ): Node = {
    val ( builtIn,
	  className ) = InstanceFactory.builtInInfo( theClass )
    try {
      <Class>
      <Name>{ theClass.name }</Name>
      <Description>{ theClass.desc }</Description>
      <Type>{ ParamType.toString( theClass.instanceType ) }</Type>
      <BuiltIn>{ builtIn.toString }</BuiltIn>
      { if ( builtIn ) 
	<JVMClassName>{ className.get }</JVMClassName>
	else Nil }
      { formalParamsToNode( theClass.validParams.values.toList ) }
      { if ( !builtIn )
	parseTreeToNode( theClass.asInstanceOf[ ParseTreeFactory[ _ ] ].tree )
        else Nil }
      </Class>
    } catch {
      case e: ClassWriteException => throw e
      case e: ClassCastException => 
	throw new ClassWriteException( "Class declared itself as a non built " +
				       "in; Name: " + theClass.name + "; " +
				       "Message: " + e.getMessage )
    }
  }

  /**
   * Packages all the given classes into nodes
   * @@param classes The classes to package
   * @@return All the classes as nodes
   */
  def classesToNodes( classes: Seq[ InstanceFactory[ _ ] ] ) =
    classes.map( classToNode( _ ) )

  /**
   * Packages the given classes into a node.
   * @@param classes The classes to package
   * @@return The classes underneath one node
   */
  def classesToNode( classes: Seq[ InstanceFactory[ _ ] ] ) = 
    classNodesToNode( classesToNodes( classes ) )

  /**
   * Packages the given class nodes as a single classes node
   * @@param classes The classes to package
   * @@return The classes in a single Classes Node
   */
  def classNodesToNode( classes: Seq[ Node ] ) = {
    <Classes>
    { classes }
    </Classes>
  }

  /**
   * Given previously written class nodes and factories that
   * have yet to be written, it will return a single Classes node
   * that contains them all.
   * @@param previous Previously written classes
   * @@param factories Factories that must be written out
   * @@return A homogeneous seq holding the previous classes and the factories
   */
  def makeClassesNode( previous: Seq[ Node ], 
		       factories: Seq[ InstanceFactory[ _ ] ] ) = {
    classNodesToNode( previous ++ classesToNodes( factories ) )
  }

  /**
   * Writes the given classes to the given file.
   * @@param classes The classes to write out
   * @@param fileName The name of the file
   * @@param append If we should append or clobber the file
   * @@throws ClassWriteException If it couldn't figure out how to
   *         write out a given class
   * @@throws IOException If an error occurred on writing
   */
  def writeClasses( classes: Seq[ InstanceFactory[ _ ] ],
		    fileName: String,
		    append: Boolean ) {
    new XMLWriter( fileName, append ).writeClasses( classes )
  }
  
  /**
   * Writes the given class to the given file.
   * @@param theClass The class to write out
   * @@param fileName The name of the file
   * @@param append If we should append or clobber the file
   * @@throws ClassWriteException If it couldn't figure out how to
   *         write out a given class
   * @@throws IOException If an error occurred on writing
   */
  def writeClass( theClass: InstanceFactory[ _ ],
		  fileName: String,
		  append: Boolean ) {
    writeClasses( Seq[ InstanceFactory[ _ ] ]( theClass ),
		  fileName,
		  append )
  }
}

/**
 * Writes out classes as XML.
 * @@param fileName The file name to write to.
 * @@param append If we should append to the file instead of clobbering it
 * @@param width The width to put the output to
 * @@param indentation The number of spaces to use for indentation
 * @@author Kyle Dewey
 */
class XMLWriter( fileName: String, 
		 val append: Boolean,
		 val width: Int,
	         val indentation: Int ) extends ClassWriter( fileName ) {
  import XMLWriter._
  private val printer = new PrettyPrinter( width,
					   indentation )
  
  /**
   * Creates a new writer with a width of
   * WIDTH and an indentation of INDENTATION.
   * @@param fileName The name of the file to write to
   * @@param append If we should append
   */
  def this( fileName: String, append: Boolean ) = 
    this( fileName, 
	  append,
	  XMLWriter.WIDTH,
	  XMLWriter.INDENTATION )
  
  /**
   * Creates a new writer with the default width and indentation
   * that doesn't append (clobbers)
   * @@param fileName The name of the file to write to
   */
  def this( fileName: String ) =
    this( fileName, false )

  /**
   * Writes all of the given classes to a file.
   * @@param classes The classes to write out
   * @@throws IOException If an error occurred on writing
   */
  def writeClasses( classes: Seq[ InstanceFactory[ _ ] ] ) = {
    import java.io._
    val additional = additionalClasses
    val writer = new BufferedWriter( new FileWriter( fileName ) )
    val output = 
      printer.format( makeClassesNode( additional,
				       classes ) )
    writer.write( output )
    writer.close()
  }

  /**
   * Gets all "additional" classes.
   * If we were set to append, then this will return all classes in
   * the original file, in order.  If we weren't set to append, this returns
   * an empty Seq.
   * @@return Either additional classes or Nil, as described above.
   */
  def additionalClasses() = {
    import sentinel.model.parser.xml._
    if ( !append ) {
      Nil
    } else {
      try {
	new XMLParser( fileName ).classes
      } catch {
	case e: Exception => Nil
      }
    }
  }
}
@


1.8
log
@Append now works correctly.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.7 2011/02/12 02:50:47 kyledewey Exp kyledewey $
d9 3
d62 3
a64 3
    <Name>{ name }</Name>
    <Type>{ ParamType.toString( constant.getType ) }</Type>
    <Value>{ constant.asInstanceOf[ Data ].data }</Value>
d74 1
a74 1
  def variableToNode( name: String, variable: Param ) = {
a75 1
    val asVar = variable.asInstanceOf[ SpreadsheetVariable ]
d77 5
a81 5
    <Name>{ name }</Name>
    <Type>{ ParamType.toString( variable.getType ) }</Type>
    <Sheet>{ asVar.sheet.getOrElse( ANY_SHEET ) }</Sheet>
    <Row>{ asVar.row.getOrElse( ANY_ROW ) }</Row>
    <Column>{ asVar.column.getOrElse( ANY_COLUMN ) }</Column>
d96 3
a98 2
      case item: Constant => constantToNode( node.name, node.item )
      case item: Variable => variableToNode( node.name, node.item )
d114 2
a115 2
    <Name>{ node.name }</Name>
    <MapsTo>{ node.mapsTo }</MapsTo>
@


1.7
log
@Now uses SpreadsheetVariable instead of just Variable.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.6 2010/07/11 05:52:47 kyledewey Exp kyledewey $
d9 3
d223 8
d235 9
a243 1
  def classesToNode( classes: Seq[ InstanceFactory[ _ ] ] ) = {
d245 1
a245 1
    { classes.map( classToNode( _ ) ) }
d248 45
d297 2
a298 2
 * @@param fileName The file name to write to.  Note that it is clobbered
 *        on write.
d304 1
d313 1
a313 1
   * WIDTH and an indentation of indentation.
d315 1
d317 1
a317 1
  def this( fileName: String ) = 
d319 1
d324 8
a332 1
   * Clobbers on write.
d338 1
d340 3
a342 1
    val output = printer.format( classesToNode( classes ) )
d346 20
@


1.6
log
@Formal parameters are no longer sorted upon being written
out; this is mostly for show.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.5 2010/06/25 03:20:25 kyledewey Exp $
d9 4
d70 1
a70 1
    val asVar = variable.asInstanceOf[ Variable ]
@


1.5
log
@Refactored so that variables have types.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.4 2010/06/20 22:54:50 kyledewey Exp kyledewey $
d9 3
d65 2
d70 3
a72 1
    <Where>{ variable.asInstanceOf[ Variable ].where }</Where>
a172 2
   * The formal parameters will first be sorted according to
   * sortParams.
d178 1
a178 1
    { ParamInfo.sortParams( params ).map( formalParamToNode( _ ) ) }
@


1.4
log
@Now capable of writing out user-defined classes.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.3 2010/06/20 17:32:39 kyledewey Exp kyledewey $
d9 3
d47 1
a47 1
  def constantToNode( name: String, constant: Constant[ _ ] ) = {
d51 1
a51 1
    <Value>{ constant.data }</Value>
d61 1
a61 1
  def variableToNode( name: String, variable: Variable ) = {
d64 2
a65 1
    <Where>{ variable.where }</Where>
d80 2
a81 2
      case item: Constant[ _ ] => constantToNode( node.name, item )
      case item: Variable => variableToNode( node.name, item )
a164 13
   * Given a bunch of params, will return them such that
   * all required params are first, and in abc order, followed
   * by all optional params in abc order.
   * @@param params The params to sort
   * @@return The same params, in a different order
   */
  def sortParams( params: Seq[ ParamInfo ] ): Seq[ ParamInfo ] = {
    val ( required,
	  optional ) = params.partition( _.isRequired )
    required.toList.sort( _ < _ ) ++ optional.toList.sort( _ < _ )
  }
    
  /**
d173 1
a173 1
    { sortParams( params ).map( formalParamToNode( _ ) ) }
@


1.3
log
@Now uses InstanceFactory[ _ ] instead of
Either[ MatcherFactory, ReplacerFactory ].
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.2 2010/06/18 19:37:35 kyledewey Exp kyledewey $
d9 4
d39 27
d74 8
a81 12
  def terminalToNode( node: TerminalNode ) = {
    try {
      <ConstantParameter>
      <Name>{ node.name }</Name>
      <Type>{ ParamType.toString( node.item.getType ) }</Type>
      <Value>{ node.item.asInstanceOf[ Data ].data }</Value>
      </ConstantParameter>
    } catch {
      case e: ClassCastException => 
	throw new ClassWriteException( "Terminal node containing " +
				       "neither a constant nor a variable." +
				       "  Found type: " +
d87 47
d139 3
d190 2
a193 1
    // TODO: user defined anything
d196 21
a216 11

    <Class>
    <Name>{ theClass.name }</Name>
    <Description>{ theClass.desc }</Description>
    <Type>{ ParamType.toString( theClass.instanceType ) }</Type>
    <BuiltIn>{ builtIn.toString }</BuiltIn>
    { if ( builtIn ) 
      <JVMClassName>{ className }</JVMClassName>
      else None }
    { formalParamsToNode( theClass.validParams.values.toList ) }
    </Class>
d225 1
a225 1
    <Class>
d227 1
a227 1
    </Class>
@


1.2
log
@Made factories take a name and description.
@
text
@d5 1
a5 1
 *     $Id: WriteXML.scala,v 1.1 2010/06/18 03:00:12 kyledewey Exp kyledewey $
d9 3
a21 2
import sentinel.model.matcher._
import sentinel.model.replacer._
d35 34
d108 1
d114 1
a114 1
  def classToNode( theClass: Either[ MatcherFactory, ReplacerFactory ] ): Node = {
d116 2
a117 6
    val ( name,
	  desc,
	  theType,
	  builtIn,
	  className,
          params ) = ClassWriter.getClassInfo( theClass )
d120 3
a122 3
    <Name>{ name }</Name>
    <Description>{ desc }</Description>
    <Type>{ theType }</Type>
d127 1
a127 1
    { formalParamsToNode( params.values.toList ) }
d136 1
a136 1
  def classesToNode( classes: Seq[ Either[ MatcherFactory, ReplacerFactory ] ] ) = {
d174 1
a174 1
  def writeClasses( classes: Seq[ Either[ MatcherFactory, ReplacerFactory ] ] ) = {
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
a33 43
   * Given a class, determines the type of the class, whether
   * or not it is a built in, and the name of the class if
   * it is a built in.
   * @@param theClass the class to get this information from
   * @@return the type of the class (MATCHER_STRING, REPLACER_STRING),
   *         whether or not the class is a built in,
   *         the JVM class name of the class (None if it is not a built in)
   *         the params the class takes
   */
  def getClassInfo( theClass: Either[ MatcherFactory, ReplacerFactory ] ) = {
    import ParamType._
    // TODO: user defined anything
    var theType: String = null
    var builtIn: Boolean = false
    var className: Option[ String ] = None
    var params: Map[ String, ParamInfo ] = null

    theClass match {
      case Left( theMatcher ) => {
	theType = MATCHER_STRING
	builtIn = theMatcher.isInstanceOf[ ReflectionMatcherFactory ]
	params = theMatcher.validParams
	if ( builtIn ) {
	  className = Some( theMatcher.asInstanceOf[ ReflectionMatcherFactory ].className )
	}
      }
      case Right( theReplacer ) => {
	theType = REPLACER_STRING
	builtIn = theReplacer.isInstanceOf[ ReflectionReplacerFactory ]
	params = theReplacer.validParams
	if ( builtIn ) {
	  className = Some( theReplacer.asInstanceOf[ ReflectionReplacerFactory ].className )
	}
      } 
    }

    ( theType,
      builtIn,
      className,
      params )
  }

  /**
a74 2
   * @@param name The name of the class
   * @@param desc A description of the class
d78 1
a78 3
  def classToNode( name: String, 
		   desc: String, 
		   theClass: Either[ MatcherFactory, ReplacerFactory ] ): Node = {
d80 3
a82 1
    val ( theType,
d85 1
a85 1
          params ) = getClassInfo( theClass )
a99 16
   * Packages the given class into a node.
   * @@param theClass The class, as a tuple of the following:
   *        -The name of the class
   *        -The class description
   *        -The class itself
   * @@return The class, as a node
   */
  def classToNode( theClass: ( String, 
			       String, 
			       Either[ MatcherFactory, ReplacerFactory ] ) ): Node = {
    classToNode( theClass._1,
		 theClass._2,
		 theClass._3 )
  }

  /**
d104 1
a104 3
  def classesToNode( classes: Seq[ ( String,
				     String,
				     Either[ MatcherFactory, ReplacerFactory ] ) ] ) = {
d142 1
a142 1
  def writeClasses( classes: Seq[ ( String, String, Either[ MatcherFactory, ReplacerFactory ] ) ] ) = {
@
