head	1.12;
access;
symbols;
locks
	kyledewey:1.12; strict;
comment	@# @;


1.12
date	2011.06.21.10.08.25;	author kyledewey;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.21.09.39.00;	author kyledewey;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.20.22.19.56;	author kyledewey;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.19.20.05.51;	author kyledewey;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.31.00.04.31;	author kyledewey;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.27.18.50.48;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.04.00.21.30;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.03.21.17.02;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.03.18.59.14;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.03.04.18.02;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.02.03.15.51;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.01.03.24.44;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains code for function creation.
@


1.12
log
@Parameter renaming now works properly.
@
text
@/*
 * Function.scala
 *
 * Version:
 *     $Id: Function.scala,v 1.11 2011/06/21 09:39:00 kyledewey Exp kyledewey $
 * 
 * Revisions:
 *      $Log: Function.scala,v $
 *      Revision 1.11  2011/06/21 09:39:00  kyledewey
 *      If a parameter isn't marked as used, it is no longer
 *      included.
 *
 *      Revision 1.10  2011/06/20 22:19:56  kyledewey
 *      Debugging nodes whose values are used as constants
 *      are now written out as constants.
 *
 *      Revision 1.9  2011/06/19 20:05:51  kyledewey
 *      Refactored PreFunctionParams.
 *      PreFunctionParam code moved to PreFunctionParam.scala.
 *
 *      Revision 1.8  2011/05/31 00:04:31  kyledewey
 *      Moved moveSubsequence() to SentinelHelpers.
 *      Moved validateChangeParameterType() to sentinel.utils.interactive.
 *
 *      Revision 1.7  2011/05/27 18:50:48  kyledewey
 *      Moved the multiMap() method to sentinel.model.SentinelHelpers.
 *
 *      Revision 1.6  2011/04/04 00:21:30  kyledewey
 *      moveSubsequence() now works correctly.
 *
 *      Revision 1.5  2011/04/03 21:17:02  kyledewey
 *      Refactored how parameters are moved.
 *
 *      Revision 1.4  2011/04/03 18:59:14  kyledewey
 *      Fixed bug where parameter renaming wasn't
 *      performed in order.
 *
 *      Revision 1.3  2011/04/03 04:18:02  kyledewey
 *      Refactored so parameter order is easier to manipulate.
 *
 * 
 *  
 */

package sentinel.vpl

import sentinel.model._
import ParamType._

/**
 * Contains constants and static routines relevant to function creation.
 * @@author Kyle Dewey
 */
object Function {
  import sentinel.model.SentinelHelpers._

  /**
   * Validates that the items seen in the given Seq are the same as those
   * in the given set.
   * @@param seq The sequence
   * @@param set The set
   * @@return true if they hold the same items, else false
   */
  def same[ T ]( seq: Seq[ T ], set: Set[ T ] ): Boolean =
    ( Set() ++ seq ) == set

  /**
   * Same as <code>same</code>, but with a different parameter order.
   * @@param set The set
   * @@param seq The seq
   * @@return <code>same( seq, set )</code>
   */
  def same[ T ]( set: Set[ T ], seq: Seq[ T ] ): Boolean =
    same( seq, set )

  /**
   * Validates that the given sequence of SentinelNodes contains
   * exactly the same nodes as seen in the given set.
   * @@param seq The sequence of SentinelNodes
   * @@param set The set of SentinelNodes
   * @@throws NodeMismatchException If the nodes in selectedNodes at all differ
   * from the order of nodes
   */
  def validateSame( seq: Seq[ SentinelNode ], set: Set[ SentinelNode ] ) {
    if ( !same( seq, set ) ) {
      throw new NodeMismatchException( "Nodes in the set differ from those " +
				       "in the sequence." )
    }
  }

  /**
   * Like <code>getTailNodes</code>, but exactly one output is expected.
   * @@param nodes The nodes that have been selected
   * @@return The output node for a function
   * @@throws BadOutputException If there is not exactly one possible output.
   */
  def getTailNode( nodes: Set[ SentinelNode ] ) = {
    val tails = getTailNodes( nodes )
    val length = tails.length
    if ( length != 1 ) {
      throw new BadOutputException( length )
    }
    tails.first
  }

  /**
   * Given a bunch of nodes, it will return nodes that either
   * have unconnected outputs or nodes that are on the border
   * of the nodes that have been connected.  In the second case,
   * consider the graph 1->2->3->4.  If this is given 1,2,3, then
   * this will return 3, as 3 is on the border of being selected.
   * This is intended for creating functions.
   * @@param nodes The nodes to search through
   * @@return The nodes that either have unconnected outputs or those
   * which are the last nodes before one goes outside of the selection
   */
  def getTailNodes( nodes: Set[ SentinelNode ] ) = {
    var seen: Set[ SentinelNode ] = Set()
    var retval: List[ SentinelNode ] = List()

    // recursively processes the given node through outputs
    def processNode( node: SentinelNode ) {
      if ( !seen.contains( node ) ) {
	// lazy because a node may not even have an output
	lazy val output = node.output.get._2.asInstanceOf[ SentinelNode ]
	seen += node
	if ( !node.outputConnected || // output not connected
	     !nodes.contains( output ) ) { // on edge
	  retval ::= node
	} else {
	  processNode( output )
	}
      }
    }

    nodes.foreach( processNode( _ ) )
    retval.reverse.toSeq
  }

  /**
   * Determines if a given node's input has any connections that are within
   * the given set.
   * @@param node The node to check
   * @@param inputName The name of the input to check
   * @@param selectedNodes The nodes that have been selected.
   * @@return True if there are any input connections to the given input that
   * are contained in selectedNodes.  If there aren't any input connections,
   * or all input connections are to nodes outside of selectedNodes, this
   * returns false
   */
  def inputConnectedTo( node: SentinelNode,
		        inputName: String,
		        selectedNodes: Set[ SentinelNode ] ) = {
    node.inputConnections( inputName )
        .map( _.asInstanceOf[ SentinelNode ] )
	.exists( selectedNodes.contains( _ ) )
  }

  /**
   * Determines if the given input should be treated as a potential
   * parameter.
   * @@param node The node with the input
   * @@param inputName The name of the input
   * @@param selectedNodes The nodes that have been selected
   * @@return true if it should be treated as a parameter, else false
   */
  def isPotentialParameter( node: SentinelNode,
			    inputName: String,
			    selectedNodes: Set[ SentinelNode ] ) = {
    !inputConnectedTo( node, 
		       inputName, 
		       selectedNodes )
  }

  /**
   * Given a node and the nodes that have been selected, it gets the names
   * of inputs that have not been connected.  Note that any nodes that
   * are outside of those nodes that have been selected are ignored.  I.e.
   * a node could be connected but if this connection isn't in the set of
   * selected nodes, then this connection is ignored and considered unconnected.
   * @@param node The node to get unconnected inputs of
   * @@param selectedNodes All the nodes that have been selected.  Any nodes
   * outside of this grouping are ignored.
   * @@return The names of unconnected inputs, or inputs that have connections
   * to nodes not seen in <code>selectedNodes</code>.
   */
  def inputConnections( node: SentinelNode,
		        selectedNodes: Set[ SentinelNode ] ): Set[ String ] = 
    Set() ++ node.inputNames
                 .filter( isPotentialParameter( node, _, selectedNodes ) )
  
  /**
   * Create a data structure describing the inputs to the function.
   * This will map nodes to their unconnected inputs.
   * @@param nodes The nodes that have been selected.  Any nodes
   * that are not selected are essentially ignored
   * @@return a mapping of nodes to their unconnected inputs
   */
  def inputConnections( nodes: Set[ SentinelNode ] ): 
  Map[ SentinelNode, Set[ String ] ] = {
    Map() ++ nodes.map( node => Pair( node, inputConnections( node, nodes ) ) )
  }
    
  /**
   * Validates that all the given input nodes are accessable via the
   * output node.  Accessible means that they are either ancestors or the node
   * itself.
   * @@param inputNodes The input nodes
   * @@param outputNode The output node
   * @@throws InputNotConnectedException If not all nodes are ancestors
   */
  def validateAccessible( inputNodes: Set[ SentinelNode ],
			  outputNode: SentinelNode ) {
    val accessible = outputNode.ancestors + outputNode
    if ( !inputNodes.forall( accessible.contains( _ ) ) ) {
      throw new InputNotConnectedException( "Input not connected to output" )
    }
  }
}

/**
 * Exception thrown when all given inputs are not ancestors of the given
 * output.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class InputNotConnectedException( message: String ) 
     extends Exception( message ) {}

/**
 * Exception thrown when there are multiple possible outputs
 * for a function, or there are no possible outputs.
 * @@param message A message to show the user
 * @@param numOutputs The number of possible outputs found
 * @@author Kyle Dewey
 */
case class BadOutputException
( message: String, val numOutputs: Int ) extends Exception( message ) {
  /**
   * Creates a new exception, using only the number of outputs.
   * A message is generated from this.
   * @@param numOutputs The number of possible outputs found
   */
  def this( numOutputs: Int ) =
    this( "Found " + numOutputs + " possible outputs.  Functions must have " +
	  "exactly one output.",
	  numOutputs )
}       

/**
 * Exception thrown when an attempt is made to make an instance factory
 * when there is insufficient information with which to make it.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class InsufficientParseTreeInformationException( message: String )
     extends Exception( message ) {}

/**
 * Exception thrown when an attempt is made to manipulate a parameter
 * that we are not aware of.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class UnknownParameterNameException( message: String )
     extends Exception( message ) {}

/**
 * Exception thrown when an attempt is made to change the name of
 * an input to a name that is already used.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class ParameterNameRepeatException( message: String )
     extends Exception( message ) {}

/**
 * Exception thrown when an attempt is made to make a function
 * with a name that is already registered.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class FunctionNameRepeatException( message: String )
     extends Exception( message ) {}

/**
 * Exception thrown when the nodes in the set of selected nodes
 * are at all different from the specified order of nodes.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class NodeMismatchException( message: String )
     extends Exception( message ) {}

/**
 * Represents a "prefunction".
 * Prefunctions know what code that they contain and hold reasonable
 * defaults for input names and types, but they do not yet exist in a form
 * that can execute code.  In this form, the user can manipulate certain
 * properties of functions, such as names, descriptions, etc. before actually
 * creating the function.
 * @@param inputConnections Nodes that contain unconnected inputs to the
 * function.  For each node, there are names of the unconnected inputs.
 * @@param selectedNodes All nodes that are in the function
 * @@param inputOrder How to order nodes.  These are the same nodes as seen
 * in selectedNodes
 * @@param outputNode The output node for the function
 * @@throws NodeMismatchException If the nodes in selectedNodes at all differ
 * from the order of nodes
 * @@throws InputNotConnectedException If there are connections missing between
 * <code>inputNodes</code> and <code>outputNode</code>, such that not all inputs
 * are ancestors of the output node.
 * @@author Kyle Dewey
 */
class PreFunction
( val inputConnections: Map[ SentinelNode, Set[ String ] ],
  val selectedNodes: Set[ SentinelNode ],
  inputOrder: Seq[ SentinelNode ],
  val outputNode: SentinelNode ) {

  import PreFunctionParam._
  import Function._
  
  // validate input parameters
  validateSame( inputOrder, 
	        selectedNodes )
  validateAccessible( inputNodes, 
		      outputNode )

  // begin instance variables
  var name: Option[ String ] = None
  var description: Option[ String ] = None
  private var _validParams = 
    makeValidParams( inputConnections,
		     inputOrder ).toArray
  private var validParamsByName = paramsMap( validParams )
  // end instance variables

  /**
   * Creates a new PreFunction, given the selected nodes and output
   * node.
   * @@param selectedNodes The nodes that have been selected
   * @@param inputOrder The order of the selected nodes
   * @@param outputNode The output node to use
   */
  def this( selectedNodes: Set[ SentinelNode ], 
	    inputOrder: Seq[ SentinelNode ],
	    outputNode: SentinelNode ) =
    this( Function.inputConnections( selectedNodes ),
	  selectedNodes,
	  inputOrder,
	  outputNode )

  /**
   * Creates a new PreFunction, given the selected nodes.
   * @@param selectedNodes The nodes that have been selected
   * @@param inputOrder The order of the selected nodes
   * @@throws BadOutputException If there are multiple
   * outputs that could be used.  A function is permitted only to
   * have exactly one.
   */
  def this( selectedNodes: Set[ SentinelNode ], 
	    inputOrder: Seq[ SentinelNode ] ) =
    this( selectedNodes,
	  inputOrder,
	  Function.getTailNode( selectedNodes ) )

  /**
   * Gets the valid parameters
   * @@return The valid parameters
   */
  def validParams() =
    _validParams

  /**
   * Validates that the given parameter names are the same as those
   * we already have
   * @@param paramNames The names of the parameters
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized, or if a parameter is missing
   */
  def validateParamsSame( paramNames: Seq[ String ] ) {
    paramNames.foreach( validateParameterName( _ ) )
    val missing = 
      ( Set() ++ validParamsByName.keySet ) -- ( Set() ++ paramNames )
    if ( !missing.isEmpty ) {
      throw new UnknownParameterNameException( "Missing the following params: " +
					       missing.toList
					              .sort( _ < _ )
					              .mkString( ", " ) )
    }
  }

  /**
   * Gets the original param info object correlating to the parameter
   * with the given name.
   * @@param name The current name of the parameter
   * @@return The original param info object correlating to the parameter
   */
  def originalParamInfo( name: String ) =
    validParamsByName( name ).originalParamInfo

  /**
   * Gets the param info object correlating to the
   * parameter with the given name.
   * @@param name The current name of the parameter
   * @@return The current param info object for the parameter
   */
  def paramInfo( name: String ) =
    validParamsByName( name ).currentParamInfo 

  /**
   * Validates that the given input name is recognized.
   * @@param name The name of the input
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def validateParameterName( name: String ) {
    if ( !validParamsByName.contains( name ) ) {
      throw new UnknownParameterNameException( "Unknown parameter with name: " + name )
    }
  }

  /**
   * Validates that the given parameter name change can occur
   * @@param name The name of the parameter
   * @@param newName The new name of the parameter
   * @@throws ParameterNameRepeatException If an attempt is made to
   * change to an existing name
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def validateChangeParameterName( name: String, newName: String ) {
    validateParameterName( name )
    if ( validParamsByName.contains( newName ) ) {
      throw new ParameterNameRepeatException( "Attempt to change parameter with name " +
					      name + " to " + newName + ", which is already " +
					      "a parameter." )
    }
  }

  /**
   * Changes something on a parameter
   * @@param name The name of the parameter
   * @@param change Function that can perform the change
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def changeParameter( name: String, 
		       change: PreFunctionParam => Unit ) {
    validateParameterName( name )
    
    val param = validParamsByName( name )
    val oldName = param.currentName
    change( param )
    val newName = param.currentName
    if ( oldName ne newName ) {
      validParamsByName -= oldName
      validParamsByName += Pair( newName, param )
    }
  }

  /**
   * Changes something on a parameter.
   * Note that this assumes that the change function
   * will perform any validation
   * @@param name The name of the parameter
   * @@param change Function that can perform the change
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def changeParamInfo( name: String, 
		       change: ParamInfo => ParamInfo ) {
    changeParameter( name,
		     ( param: PreFunctionParam ) => 
		       param.currentParamInfo = change( param.currentParamInfo ) )
  }

  /**
   * Changes the name of a parameter.
   * @@param name The name of the parameter
   * @@param newName The new name of the parameter
   * @@throws ParameterNameRepeatException If an attempt is made to
   * change to an existing name
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def changeParameterName( name: String, newName: String ) {
    validateChangeParameterName( name, newName )

    changeParamInfo( name,
		     _.newName( newName ) )
  }

  /**
   * Changes the type of a parameter.
   * @@param name The name of the parameter
   * @@param newType The new type of the parameter
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   * @@throws ParameterTypeChangeException If the type change is invalid
   */
  def changeParameterType( name: String, newType: ParamType ) {
    changeParamInfo( name,
		     _.newType( newType ) )
  }

  /**
   * Changes the description of a parameter
   * @@param name The name of the parameter
   * @@param newDesc The new description of the parameter
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def changeParameterDescription( name: String, newDesc: String ) {
    changeParamInfo( name,
		     _.newDesc( newDesc ) )
  }

  /**
   * Changes whether or not the parameter is an array.
   * @@param name The name of the parameter
   * @@param newIsArray The new isArray value
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   * @@throws ParameterArrayChangeException If the array change is invalid
   */
  def changeParameterIsArray( name: String, newIsArray: Boolean ) {
    changeParamInfo( name,
		     _.newIsArray( newIsArray ) )
  }

  /**
   * Changes whether or not the parameter is required.
   * @@param name The name of the parameter
   * @@param newIsRequired The new isRequired value
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   * @@throws ParameterRequiredException If the requirement change
   * is invalid
   */
  def changeParameterIsRequired( name: String, newIsRequired: Boolean ) {
    changeParamInfo( name,
		     _.newIsRequired( newIsRequired ) )
  }

  /**
   * Changes whether or not a parameter is used.
   * @@param name The name of the parameter
   * @@param newIsUsed The new value for whether or not it is used
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   * @@throws ParameterUsedException If the parameter isn't optional and
   * we don't want to use it
   */
  def changeParameterIsUsed( name: String, newIsUsed: Boolean ) {
    changeParameter( name,
		     _.currentIsUsed = newIsUsed )
  }

  /**
   * Changes the order of one or more parameters.
   * @@param start The starting row of parameters (inclusive)
   * @@param end The ending row of parameters (inclusive)
   * @@param to Where to put the range of parameters.  After the move,
   * <code>start</code> will be at the index <code>to</code>.
   */
  def moveParams( start: Int,
		  end: Int,
		  to: Int ) {
    _validParams = SentinelHelpers.moveSubsequence( start,
						    end,
						    to,
						    validParams ).toArray
  }
    
  /**
   * Changes the position of a parameter.
   * @@param paramNum The number of the parameter to move
   * @@param to Where to move it to.
   */
  def moveParam( paramNum: Int,
		 to: Int ) {
    moveParams( paramNum,
	        paramNum,
	        to )
  }

  /**
   * Gets the names of all inputs
   * @@return The names of all inputs.
   */
  def inputNames() =
    Set() ++ validParamsByName.keySet

  /**
   * Gets nodes that have inputs.
   * @@return all nodes with inputs
   */
  def inputNodes() =
    Set() ++ inputConnections.filter( !_._2.isEmpty ).keys

  /**
   * Gets the optional inputs for the given input node that
   * are used.
   * @@pre The node is an input node
   * @@param node The node
   * @@return The optional inputs that are used for the node
   */
  def optionalInputsUsed( node: SentinelNode ) = 
      optionalInputs( node ).filter( validParamsByName( _ ).currentIsUsed )
  
  /**
   * Gets the optional inputs for the given input node.
   * @@pre The node is an input node
   * @@param node The node
   * @@return The optional inputs for the node
   */
  def optionalInputs( node: SentinelNode ) =
    Set() ++ validParams.filter( param => 
			  ( param.node.eq( node ) &&
			    !param.currentIsRequired ) )
                        .map( _.currentName )

  /**
   * Given an input node, it gets the names of all connections that
   * must be made to it.
   * @@pre The node is an input node
   * @@param node The input node
   * @@return The names of all inputs that must be connected to it
   * to make it valid
   */
  def inputsNeeded( node: SentinelNode ) = {
    val allInputs =
      Set() ++ inputConnections( node ).map( currentName( node, _ ) )
    ( allInputs -- optionalInputs( node ) ) ++ optionalInputsUsed( node )
  }


  /**
   * Given a node and its current name, it will return its original name.
   * @@param node The node
   * @@param currentName The current name of the node
   * @@return The original name of the node
   */
  def originalName( node: SentinelNode, currentName: String ) = 
    validParams.filter( param => 
      ( param.node.eq( node ) &&
        param.currentName == currentName ) )
               .toList.first.originalName

  /**
   * Given a node and its original name, it will return
   * the current name.
   * @@param node The node
   * @@param originalName The original name of the node
   * @@return The current name of the node
   */
  def currentName( node: SentinelNode, originalName: String ) = 
    validParams.filter( param =>
      ( param.node.eq( node ) &&
       param.originalName == originalName ) )
               .toList.first.currentName

  /**
   * Adds variable nodes to the given input node.
   * These variable nodes correlate to inputs that must be
   * given.
   * @@pre The given node is an inputConnection
   * @@param asSentinel The node as a sentinel node
   * @@param asParse The node as a parse Node
   */
  def addVariableChildren( asSentinel: SentinelNode,
			   asParse: ParseNode ) {
    inputsNeeded( asSentinel ).foreach( input => {
      asParse.attach( new VariableNode( originalName( asSentinel, input ),
				        input ) )
    } )
  }

  /**
   * Makes a usable parse tree, starting at the given node.
   * The given node is assumed to not be a debugging node.
   * @@param node The root node of the tree
   * @@param name The name of the node
   * @@return A parse tree with this node as the root
   */
  def parseTreeNormalNode( node: SentinelNode, name: String ): ParseNode = {
    val asParse = node.parseTreeNode( name )

    // handle internal nodes
    node.inputConnections.keys.foreach( inputName => {
      node.inputConnections( inputName ).foreach( connectedTo => {
	val asSent = connectedTo.asInstanceOf[ SentinelNode ]
	if ( selectedNodes.contains( asSent ) ) {
	  asParse.attach( parseTree( asSent, inputName ) )
	}
      } )
    } )

    // handle inputs
    if ( inputConnections.contains( node ) ) {
      addVariableChildren( node, asParse )
    }

    asParse
  }

  /**
   * Like <code>parseTreeNormalNode</code>, though it is specialized for
   * debugging nodes.  If a debugging node isn't used as a parameter, and
   * it has nothing connected to its input, then it is treated as a constant.
   * @@param node The node
   * @@param name The name of the node
   * @@return A parse tree with this node as the root.
   */
  def parseTreeDebuggingNode( node: SentinelDebuggingNode, name: String ): ParseNode = {
    if ( !hasUsedParameter( node ) &&
	 node.numConnectedInputs == 0 ) {
      new TerminalNode( name, Constant( node.variable.variable ) )
    } else {
      parseTreeNormalNode( node, name )
    }
  }

  /**
   * Determines if the given node has inputs that are used.
   * @@param node The node to check
   * @@return true if the node is recognized and it has an input that
   * is used.  Else false.
   */
  def hasUsedParameter( node: SentinelNode ) =
    validParams.filter( _.node eq node )
	       .exists( _.currentIsUsed )
    
  /**
   * Makes a usable parse tree, starting at the given node.
   * @@pre The given node is within this function
   * @@param node The root node of the tree
   * @@param name The name of the node
   * @@return A parse tree with this base
   */
  def parseTree( node: SentinelNode, name: String ): ParseNode = 
    if ( node.isInstanceOf[ SentinelDebuggingNode ] ) {
      parseTreeDebuggingNode( node.asInstanceOf[ SentinelDebuggingNode ],
			      name )
    } else {
      parseTreeNormalNode( node, name )
    }
  
  /**
   * Makes a usable parse tree from this structure.
   */
  def parseTree(): ParseNode = 
    parseTree( outputNode, "" )

  /**
   * Creates the needed parameters for this function.
   * Note that they are returned in the proper order.
   * @@return The needed parameters for this function
   */
  def neededParams() =
    validParams.filter( _.currentIsUsed ).map( _.currentParamInfo )

  /**
   * Creates a mapping appropriate for the <code>neededParams</code>
   * parameter of <code>ParseTreeFactory</code>
   * @@return An approproate mapping as described above
   */
  def neededParamsMapping() =
    Map() ++ neededParams.map( param => 
      Pair( param.name, param ) )
  
  /**
   * Gets the order in which parameters should be returned.
   */
  def paramOrder() =
    neededParams.map( _.name ).toSeq

  /**
   * Iterates over all the pre function params in the order specified
   * by paramOrder.
   * @@param function A function to apply to each pre function param
   * @@return A parallel seq of the results
   */
  def mapPreFunctionParams[ T ]( function: PreFunctionParam => T ) =
    validParams.map( function( _ ) )

  /**
   * Iterates over all current param infos in the order specified by
   * paramOrder.
   * @@param function A function to apply to each param info object
   * @@return A parallel seq of the results
   */
  def mapParamInfos[ T ]( function: ParamInfo => T ) = 
    mapPreFunctionParams( ( p: PreFunctionParam ) =>
      function( p.currentParamInfo ) )

  /**
   * Determines if an instance factory can be created given the
   * current data.
   * @@return None if it can, else a Some holding the exception that
   * would be thrown if an attempt were made to create the factory.
   */
  def canMakeInstanceFactory() =
    if ( name.isEmpty ) {
      Some( new InsufficientParseTreeInformationException( "Functions require names." ) )
    } else if ( functionNameRepeat ) {
      Some( new InsufficientParseTreeInformationException( "Function with the given name already exists." ) )
    } else if ( description.isEmpty ) {
      Some( new InsufficientParseTreeInformationException( "Functions require descriptions." ) )
    } else if ( !outputNode.factory.isInstanceOf[ MatcherFactory ] &&
	        !outputNode.factory.isInstanceOf[ ReplacerFactory ] ) {
      Some( new InsufficientParseTreeInformationException( "Unknown kind of " +
							   "instance: " +
							   ParamType.toString( outputNode.factory
									                 .instanceType ) ) )
    } else {
      None
    }

  /**
   * Validates that an instance factory can be created.
   * This simply calls <code>canMakeInstanceFactory</code> and
   * throws the exception if one was generated.
   * @@throws InsufficientParseTreeInformationException If there isn't
   * enough information to make a tree with
   */
  def validateCanMakeInstanceFactory() {
    val exception = canMakeInstanceFactory
    if ( exception.isDefined ) {
      throw exception.get
    }
  }

  /**
   * Gets the type of instance that this would create.
   * @@return The instance type of this function
   */
  def instanceType() =
    outputNode.factory.instanceType

  /**
   * Determines if the function name is a repeat
   * @@return true if the function name is a repeat, else false.
   * Note that if the function name isn't defined, then this
   * returns false
   */
  def functionNameRepeat() =
    name match {
      case Some( n ) => {
	val manager = outputNode.factory match {
	  case m: MatcherFactory => MatcherFactoryManager
	  case r: ReplacerFactory => ReplacerFactoryManager
	  case _ => null
	}
	manager.isRegistered( n )
      }
      case None => false
    }
      
  /**
   * Attempts to make a new instance factory from this function.
   * @@throws InsufficientParseTreeInformationException If there isn't
   * enough information to make a tree with
   */
  def instanceFactory() = {
    validateCanMakeInstanceFactory()

    outputNode.factory match {
      case m: MatcherFactory => 
	new ParseTreeMatcherFactory( name.get,
				     description.get,
				     neededParamsMapping,
				     paramOrder,
				     parseTree )
      case r: ReplacerFactory =>
	new ParseTreeReplacerFactory( name.get,
				      description.get,
				      neededParamsMapping,
				      paramOrder,
				      parseTree )
      case _ => 
	throw new InsufficientParseTreeInformationException( "Bad type and validation failed." )
    }
  }
}

      
@


1.11
log
@If a parameter isn't marked as used, it is no longer
included.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.10 2011/06/20 22:19:56 kyledewey Exp $
d9 4
d633 6
a638 2
  def inputsNeeded( node: SentinelNode ) = 
    ( inputConnections( node ) -- optionalInputs( node ) ) ++ optionalInputsUsed( node )
d640 11
d659 1
a659 1
  def currentName( node: SentinelNode, originalName: String ) =
d661 2
a662 2
		 ( param.node.eq( node ) &&
		   param.originalName == originalName ) )
d676 2
a677 2
      asParse.attach( new VariableNode( input, 
				        currentName( asSentinel, input ) ) )
@


1.10
log
@Debugging nodes whose values are used as constants
are now written out as constants.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.9 2011/06/19 20:05:51 kyledewey Exp $
d9 4
d606 2
a607 2
  def optionalInputsUsed( node: SentinelNode ) =
    optionalInputs( node ).filter( validParamsByName( _ ).currentIsUsed )
d629 1
a629 1
  def inputsNeeded( node: SentinelNode ) =
d632 1
d744 1
a744 1
    validParams.map( _.currentParamInfo )
@


1.9
log
@Refactored PreFunctionParams.
PreFunctionParam code moved to PreFunctionParam.scala.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.8 2011/05/31 00:04:31 kyledewey Exp $
d9 4
d133 35
d180 1
a180 1
		        selectedNodes: Set[ SentinelNode ] ): Set[ String ] = {
d182 2
a183 11
                 .filter( name => {
		   val connections = 
		     Set() ++ node.inputConnections( name )
		                  .map( _.asInstanceOf[ SentinelNode ] )
		   val overlap = connections.intersect( selectedNodes )
		   // either nothing is connected or there is something
		   // connected that isn't in the selected nodes
		   overlap.isEmpty
		 } )
  }

d296 1
a296 1
  * @@param selectedNodes All nodes that are in the function
d659 1
a659 1
   * @@pre The given node is within this function
d662 1
a662 1
   * @@return A parse tree with this base
d664 1
a664 1
  def parseTree( node: SentinelNode, name: String ): ParseNode = {
d684 42
@


1.8
log
@Moved moveSubsequence() to SentinelHelpers.
Moved validateChangeParameterType() to sentinel.utils.interactive.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.7 2011/05/27 18:50:48 kyledewey Exp $
d9 4
d43 2
d107 1
a107 1
    var retval: Seq[ SentinelNode ] = Seq()
d117 1
a117 1
	  retval ++= Seq( node )
d125 1
a125 1
    retval
a180 151

  /**
   * Makes a PreFunctionParam object based on the given node and input.
   * @@param node The node
   * @@param input The input on the node
   * @@return A PreFunctionParam object correlating to the information
   */
  def asParam( node: SentinelNode, 
	       input: String ): PreFunctionParam = {
    val paramInfo = node.factory.validParams( input )
    PreFunctionParam( paramInfo,
		      paramInfo,
		      input,
		      node,
		      true )
  }

  /**
   * Makes PreFunctionParam objects based on the given node
   * @@param node The node
   * @@param inputs Set of unconnected inputs for the node
   * @@return PreFunctionParam objects for the node, in the order that
   * the node specifies
   */
  def asParam( node: SentinelNode, 
	       inputs: Set[ String ] ): Seq[ PreFunctionParam ] = {
    node.factory
        .paramOrder
        .filter( inputs.contains( _ ) )
        .map( asParam( node, _ ) )
  }

  /**
   * Given a sequence, determines the number of times a given item has been
   * seen.
   * @@param items The sequence of items
   * @@return A mapping of the items to the number of times that they
   * have been seen
   */
  def numTimesSeen[ T ]( items: Seq[ T ] ) = {
    var retval = Map() ++ items.map( Pair( _, 0 ) )
    items.foreach( item => {
      val oldNum = retval( item )
      retval += Pair( item, oldNum + 1 )
    })
    retval
  }

  /**
   * Gets all the repeated names in the given sequence.
   * @@param preFuncs The pre function objects to get the names of.  Note
   * that the names are extracted from <code>paramInfo.name</code>
   * @@return A set of repeated names
   */
  def repeatedNames( preFuncs: Seq[ PreFunctionParam ] ) =
    Set() ++ numTimesSeen( preFuncs.map( _.paramInfo.name ) ).filter( _._2 > 1 ).keySet

  /**
   * Renames preFuncs so that names do not collide.
   * If a name doesn't collide, then it won't be changed.  Note the
   * name refers to the name on the paramInfo object.
   * Note that this is destructive.
   * @@param preFuncs The preFuncts to rename
   */
  def renameRepeats( preFuncs: Seq[ PreFunctionParam ] ) = {
    var repeats = 
      Map() ++ repeatedNames( preFuncs ).map( Pair( _, 1 ) )

    // gets the new name to use
    def getNewName( oldName: String ) = 
      if ( repeats.contains( oldName ) ) {
	val num = repeats( oldName )
	val newName = oldName + num
	repeats += Pair( oldName, num + 1 )
	newName
      } else {
	oldName 
      }
    
    preFuncs.foreach( preFunc => {
      val oldName = preFunc.paramInfo.name
      val newName = getNewName( oldName )
      if ( oldName.ne( newName ) ) {
	preFunc.paramInfo = preFunc.paramInfo.newName( newName )
      }
    })
    preFuncs
  }

  /**
   * Makes a series of valid params given input connections and
   * the order they should go in.  "Valid" means that there won't be
   * name conflicts.
   * @@param inputConnections The input connections
   * @@param order The order params should go in
   * @@return An ordered series of parameters with distinct names
   */
  def makeValidParams( inputConnections: Map[ SentinelNode, Set[ String ] ],
		       order: Seq[ SentinelNode ] ) = {
    val retval = applyOrder( makeParams( inputConnections ),
			     order )
    renameRepeats( retval )
    retval
  }
    
  /**
   * Creates PreFunctionParams correlating to the given
   * input connections.  Note that it will not rename repeats.
   * @@param inputConnections The input connections.  A mapping of nodes
   * to their unconnected inputs
   * @@param inputOrder The order of input nodes.
   * @@return PreFunctionParam objects correlating to the given information
   */
  def makeParams( inputConnections: Map[ SentinelNode, Set[ String ] ] ) = 
    inputConnections.keys
                    .collect
                    .flatMap( node => 
		      asParam( node, inputConnections( node ) ) )

  /**
   * Creates a mapping of names of parameters to PreFunctionParam objects.
   * @@pre All parameter names are unique
   * @@param params The parameters
   * @@return A mapping of parameter names to parameters themselves
   */
  def paramsMap( params: Seq[ PreFunctionParam ] ) =
    Map() ++ params.map( param => 
      Pair( param.paramInfo.name, param ) )

  /**
   * Maps nodes to the PreFunctionParams.
   * Multiple params can be associated with the same node
   * @@param params The PreFunctionParams
   * @@return A mapping of nodes to the parameters each node has
   */
  def mapByNode( params: Seq[ PreFunctionParam ] ) = 
    SentinelHelpers.multiMap( params.map( param => 
      Pair( param.node, param ) ) )

  /**
   * Applies order to the given list of params
   * @@param params The unordered parameters
   * @@param order The order that parameters should be put in
   * @@return The same parameters in the correct order
   */
  def applyOrder( params: Seq[ PreFunctionParam ],
		  order: Seq[ SentinelNode ] ) = {
    val byNode = mapByNode( params )
    order.filter( byNode.contains( _ ) )
         .flatMap( byNode( _ ) )
  }
a248 32
 * Exception thrown when an attept is made to change whether or
 * not a parameter is an array, and the change is invalid.
 * We can always go from array to not array, but never from
 * not array to array.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class ParameterArrayChangeException( message: String ) 
     extends Exception( message ) {}

/**
 * Exception thrown when an attempt is made to change
 * whether or not a parameter is required.
 * We can always go from non required to required, but never
 * from required to not required.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class ParameterRequiredException( message: String )
     extends Exception( message ) {}

/**
 * Exception thrown when an attempt is made to not use
 * a parameter.  Optional parameters can be discarded in the
 * creation of a function, but not required parameters.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class ParameterUsedException( message: String )
     extends Exception( message ) {}

/**
a257 25
 * Simple container class representing parameters.
 * For each parameter we hold, we need to store a variety of information.
 * @@param paramInfo The param info object correlating to the parameter
 * @@param originalParamInfo The original param info object correlating to the
 * parameter
 * @@param originalName The original name of the parameter
 * @@param node The node that this parameter is associated with
 * @@param used Whether or not this parameter used
 * @@author Kyle Dewey
 */
case class PreFunctionParam( var paramInfo: ParamInfo,
			     val originalParamInfo: ParamInfo,
			     val originalName: String,
			     val node: SentinelNode,
			     var used: Boolean ) {
  /**
   * Compares the name.
   * @@param other The other param
   * @@return true if the name is different, else false
   */
  def nameDifferent( other: PreFunctionParam ) =
    paramInfo.name != other.paramInfo.name
}

/**
d283 1
d285 1
a285 1

d372 1
a372 1
    validParamsByName( name ).paramInfo 
d416 1
a416 1
    val oldName = param.paramInfo.name
d418 2
a419 2
    val newName = param.paramInfo.name
    if ( oldName.ne( newName ) ) {
d438 1
a438 1
		       param.paramInfo = change( param.paramInfo ) )
a457 43
   * Validates that the given parameter array change is valid.
   * We can always go from array -> not array, but never the opposite.
   * @@param oldIsArray the old isArray value
   * @@param newIsArray the new isArray value
   * @@throws ParameterArrayChangeException If the array change is invalid
   */
  def validateChangeParameterIsArray( oldIsArray: Boolean, newIsArray: Boolean ) {
    if ( !oldIsArray && newIsArray ) {
      throw new ParameterArrayChangeException( "Cannot go from not being an array to being an array." )
    }
  }

  /**
   * Validates that the given requirement change is valid.
   * We can always go from not being required to being required,
   * but never the opposite.
   * @@param oldIsRequired The old isRequired value
   * @@param newIsRequired The new isRequired value
   * @@throws ParameterRequiredException If the requirement change
   * is invalid
   */
  def validateChangeParameterIsRequired( oldIsRequired: Boolean, newIsRequired: Boolean ) {
    if ( oldIsRequired && !newIsRequired ) {
      throw new ParameterRequiredException( "Cannot go from being required to not being required." )
    }
  }

  /**
   * Validates that the given use change is valid.
   * Optional parameters can be discarded and not used, but only
   * optional parameters.
   * @@param optional Whether or not the parameter is optional
   * @@param use If we want to use this
   * @@throws ParameterUsedException If the parameter isn't optional and
   * we don't want to use it
   */
  def validateChangeParameterUsed( optional: Boolean, use: Boolean ) {
    if ( !optional && !use ) {
      throw new ParameterUsedException( "Cannot discard a required parameter." )
    }
  }

  /**
a465 1
    import sentinel.utils.interactive.TypeConversions._
d467 1
a467 5
		     param => {
		       validateChangeParameterType( param.paramType,
						    newType )
		       param.newType( newType )
		     } )
d492 1
a492 5
		     param => {
		       validateChangeParameterIsArray( param.isArray,
						       newIsArray )
		       param.newIsArray( newIsArray )
		     } )
d506 1
a506 5
		     param => {
		       validateChangeParameterIsRequired( param.isRequired,
							  newIsRequired )
		       param.newIsRequired( newIsRequired )
		     } )
d520 1
a520 5
		     param => {
		       validateChangeParameterUsed( !param.paramInfo.isRequired,
						    newIsUsed )
		       param.used = newIsUsed
		     } )
d563 1
a563 1
    Set() ++ inputConnections.filter( !_._2.isEmpty ).keySet
d573 1
a573 1
    optionalInputs( node ).filter( validParamsByName( _ ).used )
d584 2
a585 2
			    !param.paramInfo.isRequired ) )
                        .map( _.paramInfo.name )
d609 1
a609 1
               .toList.first.paramInfo.name
a627 10
   * Converts the given sentinel node to a ParseNode.  Note that this
   * does not descend recursively.
   * @@pre This node is within the current function
   * @@param node The node to convert.
   * @@param name The name of the node
   */
  def convertNode( node: SentinelNode, name: String ) = 
    new InternalNode( name, node.factory )
  
  /**
d635 1
a635 1
    val asParse = convertNode( node, name )
d667 1
a667 1
    validParams.map( _.paramInfo )
d685 10
a694 1
   * Iterates over all param infos in the order specified by
d696 2
a697 2
   * @@param function A function to apply to each param order object
   * @@return A parallel seq of the param orders
d700 2
a701 2
    validParams.map( ( param: PreFunctionParam ) =>
      function( param.paramInfo ) )
@


1.7
log
@Moved the multiMap() method to sentinel.model.SentinelHelpers.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.6 2011/04/04 00:21:30 kyledewey Exp $
d9 3
a58 31
   * Moves the given subsequence of a Seq to another position with the seq
   * @@param start The starting position of the subsequence
   * @@param end The ending position of the subsequence
   * @@param to Where to put the subsequence
   * @@param seq The whole sequence
   * @@return The new subsequence holding this information
   */
  def moveSubsequence[ T ]( start: Int,
			    end: Int,
			    to: Int,
			    seq: Seq[ T ] ) = {
    val move = seq.slice( start, end + 1 )
    val toItem = seq( to )

    if ( to == start ) {
      seq
    } else if ( to < end ) {
      val before = seq.slice( 0, to )
      val between = seq.slice( to + 1, start )
      val after = seq.slice( end + 1, seq.length )
      before ++ move ++ Seq( toItem ) ++ between ++ after
    } else { // to > end
      val beforeStart = seq.slice( 0, start )
      val beforeTo = seq.slice( end + 1, to )
      val between = seq.slice( to + 1, to + move.length )
      val retval = beforeStart ++ beforeTo ++ Seq( toItem ) ++ between ++ move
      retval ++ seq.slice( retval.length, seq.length )
    }
  }

  /**
a393 20
 * Exception thrown when an attempt is made to change from
 * a stronger type to a weaker type.
 * @@param message A message to show the user
 * @@author Kyle Dewey
 */
case class ParameterTypeChangeException( message: String )
extends Exception( message ) {
  /**
   * Generates a message based on the given types.
   * @@param oldType The original type
   * @@param newType The type that we are attempting to change to
   */
  def this( oldType: ParamType, newType: ParamType ) =
    this( "Attempt made to change parameter of type " +
	  ParamType.toString( oldType ) + 
	  " to parameter of incompatible type " +
	  ParamType.toString( newType ) )
}

/**
d496 1
a496 1
  private var validParams = 
d532 7
a658 20
   * Validates that the given parameter type change is valid.
   * We can move from data to anything that extends data (string, etc.)
   * We can also move from Real to Integer.  Anything else is invalid
   * @@param oldType The old type
   * @@param newType the new type
   * @@throws ParameterTypeChangeException If the type change is invalid
   */
  def validateChangeParameterType( oldType: ParamType, 
				   newType: ParamType ) {
    if ( oldType != newType ) {
      if ( ( oldType == DataType &&
	     newType == MatcherType ) ||
	   ( oldType == RealType &&
	     newType != IntType ) ) {
	throw new ParameterTypeChangeException( oldType, newType )
      }
    }
  }

  /**
d710 1
d794 4
a797 4
    validParams = moveSubsequence( start,
				   end,
				   to,
				   validParams ).toArray
@


1.6
log
@moveSubsequence() now works correctly.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.5 2011/04/03 21:17:02 kyledewey Exp kyledewey $
d9 3
a332 24
   * Given a sequence of key value pairs, makes a map so that
   * for each key, all values seen for that key are represented.
   * @@param pairs The sequence of key/value pairs
   * @@return A map where each key is represented, and the values are
   * all values seen for the given key.  Order is retained.
   */
  def multiMap[ K, V ]( pairs: Seq[ Pair[ K, V ] ] ) = {
    var retval: Map[ K, List[ V ] ] = Map()

    pairs.foreach( pair => {
      val key = pair._1
      val value = pair._2
      if ( retval.contains( key ) ) {
	val newValue = value :: retval( key )
	retval += Pair( key, newValue )
      } else {
	retval += Pair( key, List( value ) )
      }
    })
    retval.transform( ( key, list ) => 
      list.reverse.toSeq )
  }

  /**
d339 1
a339 1
    multiMap( params.map( param => 
@


1.5
log
@Refactored how parameters are moved.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.4 2011/04/03 18:59:14 kyledewey Exp kyledewey $
d9 3
d64 2
a65 22
    if ( start == to ) {
      seq 
    } else {
      val beforeMove =
	seq.slice( 0, Math.min( start, to ) )
      val afterMove =
	if ( end > to ) 
	  seq.slice( end + 1, seq.length )
	else
	  seq.slice( to, seq.length )
      val betweenMove =
	if ( to < start ) 
	  seq.slice( to, start )
	else
	  seq.slice( end + 1, to )
      val move =
	seq.slice( start, end + 1 )
      val between =
	if ( to < start )
	  move ++ betweenMove
	else
	  betweenMove ++ move
d67 13
a79 1
    beforeMove ++ between ++ afterMove
@


1.4
log
@Fixed bug where parameter renaming wasn't
performed in order.
@
text
@d5 1
a5 1
 *     $Id: Function.scala,v 1.3 2011/04/03 04:18:02 kyledewey Exp kyledewey $
d9 4
d21 1
d50 39
d880 4
a883 5
    val beforeMove = validParams.slice( 0, to )
    val toMove = validParams.slice( start, end + 1 )
    val clobbered = validParams.slice( to, end - start + 1 )
    val afterMove = validParams.slice( end + 1, validParams.length )
    beforeMove ++ toMove ++ clobbered ++ afterMove
d887 12
@


1.3
log
@Refactored so parameter order is easier to manipulate.
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d249 17
a265 1
  
d268 1
a268 1
   * input connections
d274 5
a278 9
  def makeValidParams( inputConnections: Map[ SentinelNode, Set[ String ] ] ) = {
    val retval = 
      inputConnections.keys
                      .collect
                      .flatMap( node => 
			asParam( node, inputConnections( node ) ) )
    renameRepeats( retval )
    retval
  }
d527 2
a528 2
    applyOrder( makeValidParams( inputConnections ),
	        inputOrder ).toArray
d836 4
a839 4
    val beforeMove = validParams.slice( 0, to ).force
    val toMove = validParams.slice( start, end + 1 ).force
    val clobbered = validParams.slice( to, end - start + 1 ).force
    val afterMove = validParams.slice( end + 1, validParams.length ).force
@


1.2
log
@Refactored so that parameters are much easier to manipulate.
@
text
@d4 7
a160 1
   * Note that it merely uses 0 for the order
d172 1
a172 2
		      true,
		      0 )
a190 12
   * Given a sequence of PreFunctionParam objects, it will set the
   * order values to make it so they correlate to the order seen
   * in the sequence.
   * @@param preFuncs The PreFunctionParam objects
   * @@return A new seq of PreFunctionParam objects with the order set
   * like it is in the order of the sequence
   */
  def applyParamOrder( preFuncs: Seq[ PreFunctionParam ] ) =
    List.map2( preFuncs.toList,
	       0.until( preFuncs.length ).toList )( _.newOrder( _ ) ).toSeq

  /**
d218 2
a219 1
   * name refers to the name on the paramInfo object
a220 2
   * @@return A renamed sequence of preFuncs.  A repeat of the name "repeat"
   * will be renamed to "repeat1", "repeat2", etc.
d237 1
a237 1
    preFuncs.map( preFunc => {
d241 1
a241 3
	preFunc.newParamInfo( preFunc.paramInfo.newName( newName ) )
      } else {
	preFunc
d244 1
d249 1
a249 1
   * input connections and the given parameter order.
d255 1
a255 2
  def makeValidParams( inputConnections: Map[ SentinelNode, Set[ String ] ],
		       inputOrder: Seq[ SentinelNode ] ) = {
d257 63
a319 3
      inputOrder.filter( inputConnections.contains( _ ) )
                .flatMap( node => asParam( node, inputConnections( node ) ) )
    renameRepeats( applyParamOrder( retval ) ) 
a457 1
 * @@param order The order of this parameter
d460 1
a460 1
case class PreFunctionParam( val paramInfo: ParamInfo,
d464 1
a464 2
			     val used: Boolean,
			     val order: Int ) extends Ordered[ PreFunctionParam ] {
d466 3
a468 39
   * Compares this PreFunctionParam to another one.
   * The comparison is based on order
   * @@param other The other PreFunctionParam
   * @@return <code>order.compare( other.order )</code>
   */
  def compare( other: PreFunctionParam ) =
    order.compare( other.order )

  /**
   * Creates a new object with the given param info object
   * @@param newParamInfo The new param info object
   * @@return A new object containing the same info as the old, but
   * with the newParamInfo object
   */
  def newParamInfo( newParamInfo: ParamInfo ) =
    PreFunctionParam( newParamInfo,
		      originalParamInfo,
		      originalName,
		      node,
		      used,
		      order )

  /**
   * "Changes" the value of used via copying.
   * @@param newUsed The new used value
   * @@return A new object holding the new used value
   */
  def newUsed( newUsed: Boolean ) =
    PreFunctionParam( paramInfo,
		      originalParamInfo,
		      originalName,
		      node,
		      newUsed,
		      order )

  /**
   * "Changes" the value of order via copying.
   * @@param newOrder The new order value
   * @@return A new object holding the new order value
d470 2
a471 7
  def newOrder( newOrder: Int ) =
    PreFunctionParam( paramInfo,
		      originalParamInfo,
		      originalName,
		      node,
		      used,
		      newOrder )
d499 8
a506 2
  Function.validateSame( inputOrder, selectedNodes )
  Function.validateAccessible( inputNodes, outputNode )
d511 4
a514 6

  // maps parameter names to PreFunctionParam objects
  private var validParams =
    Map() ++ Function.makeValidParams( inputConnections,
				       inputOrder ).map( param => 
					 Pair( param.paramInfo.name, param ) )
d547 19
d572 1
a572 1
    validParams( name ).originalParamInfo
d581 1
a581 1
    validParams( name ).paramInfo 
d590 1
a590 1
    if ( !validParams.contains( name ) ) {
d606 1
a606 1
    if ( validParams.contains( newName ) ) {
d614 21
d643 5
a647 6
  def changeParameter( name: String, change: ParamInfo => ParamInfo ) {
    validateParameterName( name )

    val newParamInfo = change( paramInfo( name ) )
    val newParam = validParams( name ).newParamInfo( newParamInfo )
    validParams += Pair( name, newParam )
d662 1
a662 1
    changeParameter( name,
a663 3
    val valueAdded = validParams( newName )
    validParams -= name
    validParams += Pair( newName, valueAdded )
d738 6
a743 5
    validateParameterName( name )
    validateChangeParameterType( originalParamInfo( name ).paramType,
				 newType )
    changeParameter( name,
		     _.newType( newType ) )
d754 1
a754 1
    changeParameter( name,
d767 6
a772 5
    validateParameterName( name )
    validateChangeParameterIsArray( originalParamInfo( name ).isArray,
				    newIsArray )
    changeParameter( name,
		     _.newIsArray( newIsArray ) )
d785 6
a790 5
    validateParameterName( name )
    validateChangeParameterIsRequired( originalParamInfo( name ).isRequired,
				       newIsRequired )
    changeParameter( name,
		     _.newIsRequired( newIsRequired ) ) 
d803 6
a808 6
    validateParameterName( name )
    validateChangeParameterUsed( !originalParamInfo( name ).isRequired,
				 newIsUsed )
    val newParam = validParams( name ).newUsed( newIsUsed )
    validParams -= name
    validParams += Pair( name, newParam )
d812 17
d833 1
a833 1
    Set() ++ validParams.keySet
d850 1
a850 1
    optionalInputs( node ).filter( validParams( _ ).used )
d859 1
a859 3
    Set() ++ validParams.values
                        .collect
                        .filter( param => 
d883 1
a883 2
    validParams.values
               .filter( param =>
d950 1
d954 1
a954 1
    validParams.values.map( _.paramInfo )
d969 1
a969 5
    validParams.values
               .toList
               .sort( _ < _ )
               .map( _.paramInfo.name )
               .toSeq
d977 3
a979 7
  def mapParamInfos[ T ]( function: ParamInfo => T ) = {
    val mapping = neededParamsMapping
    val order = paramOrder.toArray

    ( 0.until( order.length ) ).map( ( index: Int ) =>
      function( mapping( order( index ) ) ) ).toSeq
  }
@


1.1
log
@Initial revision
@
text
@d16 34
d59 1
a59 3
      throw new BadOutputException( "Found " + Integer.toString( length ) +
				    " possible outputs.  Functions must have " +
				    "exactly one output." )
d153 56
a208 32
   * Given a mapping of sentinel nodes to unconnected inputs, gets
   * the param info objects that correlate to those input names.
   * Note that the original input names ultimately do not change - these need
   * to be fed to the node.  However, we can use any input names that we
   * want for the function as a whole.
   * @@param mapping A mapping of sentinel nodes to their unconnected inputs
   * @@return A mapping of these nodes to another mapping of original
   * (unmodifiable) names to paraminfo objects.  Note that ultimately
   * all input names to the function need to be different, and this does
   * not guarentee that this will occur.
   */
  def getParamInfos( mapping: Map[ SentinelNode, Set[ String ] ] ) =
    mapping.transform( ( node, inputs ) =>
      Map() ++ inputs.map( input => 
	Pair( input, node.factory.validParams( input ) ) ) )

  /**
   * Given a bunch of ParamInfo objects, it will return a sequence of
   * repeated names.
   * @@param paramInfos Param info objects
   * @@return Any repeated names.
   */
  def repeatedNames( paramInfos: Seq[ ParamInfo ] ): Set[ String ] = {
    var seen: Set[ String ] = Set()
    var repeats: Set[ String ] = Set()

    paramInfos.map( _.name ).foreach( current => {
      if ( !seen.contains( current ) ) {
	seen += current
      } else {
	repeats += current
      }
d210 1
a210 1
    repeats
d212 1
a212 1
  
d214 3
a216 3
   * Given the result of <code>getParamInfos</code>, it will return those
   * param names that are repeats.
   * @@param mapping The mapping generated by <code>getParamInfos</code>
d219 3
a221 4
  def repeatedNames( mapping: Map[ SentinelNode, Map[ String, ParamInfo ] ] ):
  Set[ String ] =
    repeatedNames( mapping.values.collect.flatMap( _.values.collect ) )
  
d223 31
a253 21
   * Given the result of <code>getParamInfos</code>, it will rename the
   * ParamInfo objects to that input names are all valid.  In the case of
   * a repeated name, it will name it as "Name1", "Name2", etc.
   * @@param mapping The mapping generated by <code>getParamInfos</code>
   * @@return A new mapping, where ParamInfo objects are renamed so that
   * there are no repeats.  Note that the original parameter name is unchanged
   */
  def renameRepeats( mapping: Map[ SentinelNode, Map[ String, ParamInfo ] ] ) = {
    val repeats = repeatedNames( mapping )
    var currentUse =
      Map() ++ repeats.map( Pair( _, 0 ) )

    mapping.transform( ( node, paramInfos ) =>
      paramInfos.transform( ( originalName, paramInfo ) => {
	val name = paramInfo.name
	if ( repeats.contains( name ) ) {
	  currentUse += Pair( name, currentUse( name ) + 1 )
	  paramInfo.newName( name + 
			     Integer.toString( currentUse( name ) ) )
	} else paramInfo
      } ) )
d257 14
a270 44
   * Makes valid <code>ParamInfo</code> objects, given a mapping of
   * sentinel nodes to unconnected inputs.
   * @@param inputConnections The input connections, as described above.
   * @@return A mapping of nodes to additional mappings of original input
   * names to valid ParamInfo objects correlating to the input name.
   */
  def makeValidParams( inputConnections: Map[ SentinelNode, Set[ String ] ] ) =
    renameRepeats( getParamInfos( inputConnections ) )
  
  /**
   * Gets a mapping of nodes to sets of optional original input names.
   * @@param mapping Mapping from <code>makeValidParams</code>
   * @@return A mapping of nodes to sets of optional original input names
   */
  def optionalNames( mapping: Map[ SentinelNode, Map[ String, ParamInfo ] ] ):
  Map[ SentinelNode, Set[ String ] ] =
    mapping.transform( ( node, originalMapping ) =>
      Set() ++ originalMapping.filter( pair => 
	!pair._2.isRequired ).keys )

  /**
   * Given the output of <code>optionalNames</code>, it returns a mapping
   * of nodes to a mapping of input names to booleans.  The booleans are
   * intended to represent whether or not the final output function will
   * include this optional parameter.  By default, it sets this to true,
   * indicating that it will.
   * @@param mapping The mapping generated by <code>optionalNames</code>
   * @@return a new mapping as described above
   */
  def addBooleansToMapping( mapping: Map[ SentinelNode, Set[ String ] ] ) =
    mapping.transform( ( node, optionalInputs ) =>
      Map() ++ optionalInputs.map( inputName =>
	Pair( inputName, true ) ) )
  
  /**
   * Makes a structure describing what optional parameters should be
   * used for the given inputs to the given node.
   * @@param mapping The mapping generated by <code>makeValidParams</code>
   * @@return A mapping of nodes to a mapping of original optional input
   * names to booleans, initially set to true, indicating that the
   * given optional param should be in the final output.
   */
  def makeOptionalNames( mapping: Map[ SentinelNode, Map[ String, ParamInfo ] ] ) =
    addBooleansToMapping( optionalNames( mapping ) )
d286 1
d289 12
a300 2
case class BadOutputException( message: String )
     extends Exception( message ) {}
d391 77
d476 3
a478 1
 * @@param selectedNodes All nodes that are in the function
d480 2
d490 1
d492 1
d498 6
a503 3
  private var validParams = Function.makeValidParams( inputConnections )
  private var optionalUsed = Function.makeOptionalNames( validParams )
  private var originalParamInfos = neededParamsMapping
d510 1
d513 3
a515 1
  def this( selectedNodes: Set[ SentinelNode ], outputNode: SentinelNode ) =
d518 1
d524 1
d529 2
a530 1
  def this( selectedNodes: Set[ SentinelNode ] ) =
d532 1
d536 18
d560 1
a560 1
    if ( !inputNames.contains( name ) ) {
d576 1
a576 1
    if ( inputNames.contains( newName ) ) {
d595 3
a597 6
    val ( node,
	  originalName,
	  paramInfo ) = parameter( name )
    val newParamInfo = change( paramInfo )
    val newInnerMap = validParams( node ) + Pair( originalName, newParamInfo )
    validParams += Pair( node, newInnerMap )
d614 3
a616 3
    val paramInfo = originalParamInfos( name )
    originalParamInfos -= name
    originalParamInfos += Pair( newName, paramInfo )
d692 1
a692 1
    validateChangeParameterType( originalParamInfos( name ).paramType,
d720 1
a720 1
    validateChangeParameterIsArray( originalParamInfos( name ).isArray,
d737 1
a737 1
    validateChangeParameterIsRequired( originalParamInfos( name ).isRequired,
d754 1
a754 1
    validateChangeParameterUsed( !originalParamInfos( name ).isRequired,
d756 3
a758 31
    val ( node,
	  originalName,
	  paramInfo ) = parameter( name )
    val newInnerMap = optionalUsed( node ) + Pair( originalName, newIsUsed )
    optionalUsed += Pair( node, newInnerMap )
  }

  /**
   * Gets the map that correlates to the parameter with the given name.
   * @@param name The name of the parameter
   * @@return A tuple of the form (Node, OriginalParamName, ParamInfo)
   * @@throws UnknownParameterNameException If the given parameter
   * name isn't recognized
   */
  def parameter( name: String ) = {
    validateParameterName( name )
    var node: SentinelNode = null
    var originalName: String = null
    var paramInfo: ParamInfo = null

    validParams.foreach( outerMap => {
      validParams( outerMap._1 ).foreach( innerMap => {
	if ( innerMap._2.name == name ) {
	  node = outerMap._1
	  originalName = innerMap._1
	  paramInfo = innerMap._2
	}
      })
    })

    ( node, originalName, paramInfo )
d766 1
a766 1
    Set() ++ neededParamsMapping.keySet
d773 1
a773 1
    Set() ++ inputConnections.filter( pair => !pair._2.isEmpty ).keySet
d783 2
a784 2
    Set() ++ optionalUsed( node ).filter( pair => pair._2 ).keys

d792 6
a797 1
    Set() ++ optionalUsed( node ).keys
d811 14
d836 1
a836 1
				        validParams( asSentinel )( input ).name ) )
d889 1
a889 1
    validParams.values.collect.flatMap( _.values.collect )
a901 1
   * @@todo Add a way to make this by how they are ordered visually
d904 5
a908 1
    neededParams.map( _.name ).toList.sort( _ < _ )
d918 1
a918 1
    val order = paramOrder.toSeq
@
