head	1.6;
access;
symbols;
locks
	kyledewey:1.6; strict;
comment	@# @;


1.6
date	2011.06.08.04.33.12;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.01.03.24.44;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2011.02.27.22.33.07;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2011.02.27.04.29.17;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2011.02.26.04.14.03;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2011.02.25.20.56.03;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains GUI code for a node.
@


1.6
log
@Now conforms to the new interface for simple variables.
@
text
@/*
 * VisualNode.scala
 *
 * Version:
 *     $Id: VisualNode.scala,v 1.5 2011/04/01 03:24:44 kyledewey Exp kyledewey $
 *
 * Revisions:
 *      $Log: VisualNode.scala,v $
 *      Revision 1.5  2011/04/01 03:24:44  kyledewey
 *      Added the sortNodes() method.
 *
 *      Revision 1.4  2011/02/27 22:33:07  kyledewey
 *      Moved disconnect() routine in the singleton object
 *      to a method in Node.
 *
 *      Revision 1.3  2011/02/27 04:29:17  kyledewey
 *      Refactored for use with debuggers.
 *
 *      Revision 1.2  2011/02/26 04:14:03  kyledewey
 *      No longer a JComponent.  Added code for handling
 *      debugging tools.
 *
 *      Revision 1.1  2011/02/25 20:56:03  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.vpl

import sentinel.model._
import javax.swing._
import java.awt._

/**
 * Holds constants for visual nodes.
 * @@author Kyle Dewey
 */
object VisualNode {
  // size of input/outputs
  val INPUT_WIDTH = 5
  val INPUT_HEIGHT = 5

  // default line color
  val DEFAULT_LINE_COLOR = Color.BLACK

  // amount to subtract from the width and height
  // for drawing text
  val DRAW_TEXT_WIDTH_ADD = 0
  val DRAW_TEXT_HEIGHT_ADD = -INPUT_HEIGHT

  // text colors
  val NORMAL_TEXT_COLOR = Color.BLACK
  val TRUNCATED_TEXT_COLOR = Color.BLUE

  /**
   * Given a node, a board, and a label, it will create a visual version
   * of the node.  Note that the given label may not be used depending
   * on the type of the node
   * @@param node The node
   * @@param board The board that the node is on
   * @@param label A label for the node.  Possibly won't be used.
   * @@return A specific visual node for the given needs
   */
  def apply[ T <: AnyRef, U ]( node: Node[ T, U ],
			       board: NodeBoard[ T, U ],
			       label: String ): VisualNode[ T, U ] = {
    import sentinel.model.replacer._

    node match {
      case d: SentinelDebuggingNode =>
	new DebuggingNode( d, board.asInstanceOf[ NodeBoard[ InstanceFactory[ _ ], Param ] ] )
      case s: SentinelNode =>
	new VisualNode[ T, U ]( s, board, s.factory.name )
      case _ =>
	new VisualNode[ T, U ]( node, board, label )
    }
  }

  /**
   * Draws a filled rectangle on the given graphics, using the given
   * top left and bottom right corners of the rectangle.
   * @@param points The top left and bottom right corners of the rectangle
   * @@param color The color to draw the rectangle
   * @@param graphics The graphics object to draw on
   */
  def fillRect( points: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
	        color: Color,
	        graphics: Graphics ) {
    val oldColor = graphics.getColor
    graphics.setColor( color )
    graphics.fillRect( points._1._1,
		       points._1._2,
		       points._2._1 - points._1._1,
		       points._2._2 - points._1._2 )
    graphics.setColor( oldColor )
  }

  /**
   * Draws a string of the given maximum width of the given color.
   * @@param string The string to draw
   * @@param x The x position of the string
   * @@param y The y position of the string
   * @@param maxWidth the maximum width of the string
   * @@param normalColor Color of the string if the string didn't need
   * to be truncated
   * @@param truncColor Color of the string if it needed to be truncated
   * @@param graphics The graphics object to draw with
   */
  def drawString( string: String,
		  x: Int,
		  y: Int,
		  maxWidth: Int,
		  normalColor: Color,
		  truncColor: Color,
		  graphics: Graphics ) {
    val oldColor = graphics.getColor
    val truncated = truncateString( string,
				    graphics,
				    maxWidth )
    val newColor = 
      if ( truncated.length == string.length ) 
	normalColor 
      else 
	truncColor

    graphics.setColor( newColor )
    graphics.drawString( truncated,
			 x, y )
    graphics.setColor( oldColor )
  }

  /**
   * Like <code>drawString</code>, but it uses <code>NORMAL_TEXT_COLOR</code>
   * and <code>TRUNCATED_TEXT_COLOR</code>.
   * @@param string The string to draw
   * @@param x The x position to draw at
   * @@param y The y position to draw at
   * @@param maxWidth The maximum width of the string
   * @@param graphics The graphics object to draw with
   */
  def drawString( string: String,
		  x: Int,
		  y: Int,
		  maxWidth: Int,
		  graphics: Graphics ) {
    drawString( string,
	        x, y,
	        maxWidth,
	        NORMAL_TEXT_COLOR,
	        TRUNCATED_TEXT_COLOR,
	        graphics )
  }

  /**
   * Determines if the given point is within the rectangle dictated
   * by the given coordinates.
   * @@param point The point to determine
   * @@param topLeft The top left corner of the rectangle
   * @@param bottomRight The bottom right corner of the rectangle
   * @@return true if the point is within the rectange, else false
   */
  def pointWithin( point: Pair[ Int, Int ], 
		   topLeft: Pair[ Int, Int ], 
		   bottomRight: Pair[ Int, Int ] ) = {
    point._1 >= topLeft._1 &&
    point._1 <= bottomRight._1 &&
    point._2 >= topLeft._2 &&
    point._2 <= bottomRight._2
  }

  /**
   * Gets the Euclidean distance between two points
   * @@param point1 The first point
   * @@param point2 The second point
   * @@return The distance between the two
   */
  def distance( point1: Pair[ Int, Int ], point2: Pair[ Int, Int ] ): Double =
    distance( point1._1,
	      point1._2,
	      point2._1,
	      point2._2 )
  
  /**
   * Gets the Euclidean distance between two points
   * @@param px The first point's x
   * @@param py The first point's y
   * @@param qx The second point's x
   * @@param qy The second point's y
   * @@return The distance between the two
   */
  def distance( px: Int, py: Int, qx: Int, qy: Int ): Double =
    Math.sqrt( Math.pow( px - qx, 2 ) + 
	       Math.pow( py - qy, 2 ) )
  
  /**
   * Gets the width of the given box
   * @@param box The box
   * @@return The width of the box
   */
  def width( box: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ) =
    box._2._1 - box._1._1

  /**
   * Gets the height of the given box
   * @@param box The box
   * @@return The height of the box
   */
  def height( box: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ) =
    box._2._2 - box._1._2

  /**
   * Given a box, returns a point for each edge.  The point is in the middle
   * of the edge.
   * @@param box The box to get the mid points of
   * @@return The middle point for each of the edges
   */
  def edgeMidPoints( box: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ) = {
    val middleX = ( width( box ) / 2 ) + box._1._1
    val middleY = ( height( box ) / 2 ) + box._1._2
    
    Seq( Pair( middleX, box._1._2 ),
	 Pair( middleX, box._2._2 ),
	 Pair( box._1._1, middleY ),
	 Pair( box._2._1, middleY ) )
  }
  
  /**
   * Given two boxes, gets the two points that should be used as
   * end points between a line between them.  It picks the closest edge.
   * @@param box1 The first box
   * @@param box2 The second box
   * @@return The points that should be used as edge points for a line
   */
  def lineEndPoints( box1: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
		     box2: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ) = {
    var firstPoint: Pair[ Int, Int ] = null
    var secondPoint: Pair[ Int, Int ] = null
    var retvalDistance = 0.0

    edgeMidPoints( box1 ).foreach( ( box1Edge: Pair[ Int, Int ] ) => {
      edgeMidPoints( box2 ).foreach( ( box2Edge: Pair[ Int, Int ] ) => {
	val currentDistance = distance( box1Edge, box2Edge )

	if ( firstPoint == null ||
	     currentDistance < retvalDistance ) {
	  retvalDistance = currentDistance
	  firstPoint = box1Edge
	  secondPoint = box2Edge
	}
      })
    })

    Pair( firstPoint,
	  secondPoint )
  }
    
  /**
   * Draws a line between the two boxes.  The line is put at
   * the center of the edge closest to the other
   * @@param box1 The first box
   * @@param box2 The second box
   * @@param color The color to draw the line
   * @@param graphics The graphics object to draw with
   */
  def drawLineBoxes( box1: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
	             box2: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
	             color: Color,
	             graphics: Graphics ) {
    val ( firstPoint,
	  secondPoint ) = lineEndPoints( box1, box2 )
    drawLinePoints( firstPoint,
		    secondPoint,
		    color,
 		    graphics )
  }

  /**
   * Like <code>drawLine</code>, but it uses DEFAULT_LINE_COLOR.
   * @@param box1 The first box
   * @@param box2 The second box
   * @@param graphics The graphics object to draw with
   */
  def drawLineBoxes( box1: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
	             box2: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ],
	             graphics: Graphics ) {
    drawLineBoxes( box1,
		   box2,
 		   DEFAULT_LINE_COLOR,
		   graphics )
  }

  /**
   * Draws a line between the two given points.
   * @@param point1 The first point
   * @@param point2 The second point
   * @@param color The color of the line
   * @@param graphics The graphics object to draw with
   */
  def drawLinePoints( point1: Pair[ Int, Int ],
	              point2: Pair[ Int, Int ],
	              color: Color,
	              graphics: Graphics ) {
    val oldColor = graphics.getColor
    graphics.setColor( color )
    graphics.drawLine( point1._1,
		       point1._2,
		       point2._1,
		       point2._2 )
    graphics.setColor( oldColor )
  }

  /**
   * Draws a line between the two given points.
   * Uses <code>DEFAULT_LINE_COLOR</code>
   * @@param point1 The first point
   * @@param point2 The second point
   * @@param graphics The graphics object to draw with
   */
  def drawLinePoints( point1: Pair[ Int, Int ],
	              point2: Pair[ Int, Int ],
	              graphics: Graphics ) {
    drawLinePoints( point1,
		    point2,
		    DEFAULT_LINE_COLOR,
		    graphics )
  }

  /**
   * Given a string and a graphics object that is to draw the string,
   * it returns the width of the given string.
   * @@param string The string to get the width of
   * @@param graphics The graphics object that is to draw the string
   * @@return The width of the string, in pixels, if it were to be drawn
   * by the given graphics object
   */
  def width( string: String, graphics: Graphics ) =
    graphics.getFontMetrics
            .getStringBounds( string, graphics )
            .getWidth
  
  /**
   * Given a string, a graphics object used to draw the string,
   * and a target width, it will return a truncated string that is no
   * larger than the target width.
   * @@param string The string to truncate
   * @@param graphics The graphics object that is to draw the string
   * @@param widthTarget The target width of the string
   * @@return A truncated string that will fit in the given width
   */
  final def truncateString( string: String, 
			    graphics: Graphics, 
			    widthTarget: Int ): String = {
    if ( string == "" ||
	 width( string, graphics ) <= widthTarget ) 
      string
    else
      truncateString( string.substring( 0, string.length - 1 ),
		      graphics,
		      widthTarget )
  }

  /**
   * Orders all the given nodes by their X positions on the board.
   * Assumes that all nodes are on the same board (results will be given
   * if not, but they won't be valid.)
   * @@param nodes The nodes to sort by X position
   * @@return The sorted nodes
   */
  def sortNodes[ T <: AnyRef, U ]( nodes: Seq[ VisualNode[ T, U ] ] ) =
    nodes.toList.sort( _.topLeftCorner._1 < _.topLeftCorner._1 ).toSeq
}

/**
 * Represents a node in the GUI.
 * Such nodes are based on actual Nodes.  However, this class contains
 * code for specifically manipulating nodes in the GUI.  Note that there is
 * no code for painting connections.  Connections must be painted last, and
 * there is no good way of enforcing this from the perspective of a single node.
 * @@param node The node that this is supposed to be painting
 * @@param board The board that the node is on
 * @@param label A text label for the node
 * @@author Kyle Dewey
 */
class VisualNode[ T <: AnyRef, U ]( val node: Node[ T, U ],
			            val board: NodeBoard[ T, U ],
				    private var _label: String ) {
  /**
   * Gets the value of the label
   * @@return The value of the label
   */
  def label = 
    _label
    
  /**
   * Sets the value of the label
   * @@param newLabel The new value of the label
   */
  def label_=( newLabel: String ): Unit =
    _label = newLabel

  /**
   * Gets the top left corner of this node.
   * @@return The top left corner of this node
   */
  def topLeftCorner() =
    board.getCorner( node ).get

  /**
   * Gets the width of this node.
   * @@return The width of this node
   */
  def width() = node.width

  /**
   * Gets the height of this node
   * @@return The height of this node
   */
  def height() = node.height

  /**
   * Gets the bottom right corner of this node.
   * @@return The bottom right corner of this node
   */
  def bottomRightCorner() = {
    val topLeft = topLeftCorner
    Pair( topLeft._1 + width,
	  topLeft._2 + height )
  }
  
  /**
   * Gets the amount that each input should be staggered on the x axis for
   * this node.
   * @@return The amount of stagger for each input on the x axis
   */
  def stagger() = {
    val numInputs = node.numInputs
    Math.ceil( ( width - ( VisualNode.INPUT_WIDTH * numInputs ) ) / 
	      ( numInputs + 1 ).asInstanceOf[ Double ] ).asInstanceOf[ Int ]
  }

  /**
   * Gets where the output box should be for this node.
   * The output box is represented as a top left corner
   * and a bottom right corner.
   * @@return The position of the output box
   */
  def outputBoxPosition() = {
    val bottomRight = bottomRightCorner
    Pair( Pair( bottomRight._1 - VisualNode.INPUT_WIDTH,
	        bottomRight._2 - VisualNode.INPUT_HEIGHT ),
	  bottomRight )
  }

  /**
   * Returns the positions of each of the input boxes for this node.
   * Each position is represented as a pair of coordinate pairs.
   * @@return The positions of the input boxes
   */
  def inputBoxPositions() = {
    val topLeft = topLeftCorner
    var retval: Seq[ Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ] = Seq()
    var currentX = stagger

    while( currentX < width ) {
      retval ++= Seq( Pair( Pair( topLeft._1 + currentX,
				  topLeft._2 ),
			    Pair( topLeft._1 + currentX + VisualNode.INPUT_WIDTH,
				  topLeft._2 + VisualNode.INPUT_HEIGHT ) ) )
      currentX += stagger + VisualNode.INPUT_WIDTH
    }

    retval
  }

  /**
   * Paints out the main rectangle of this node.
   * @@param graphics The graphics object to paint with
   */
  def paintNodeBase( graphics: Graphics ) {
    VisualNode.fillRect( Pair( topLeftCorner,
		               bottomRightCorner ),
			 node.color,
			 graphics )
  }

  /**
   * Paints all the input lines of this node
   * @@param graphics The graphics object to paint with
   */
  def paintInputLines( graphics: Graphics ) {
    var currentInput = 0
    inputBoxPositions.foreach( 
      ( box: Pair[ Pair[ Int, Int ], Pair[ Int, Int ] ] ) => {
	VisualNode.fillRect( box,
			     node.inputColor( currentInput ),
			     graphics )
	currentInput += 1
      })
  }

  /**
   * Paints the output line of this node
   * @@param graphics The graphics object to paint with
   */
  def paintOutputLine( graphics: Graphics ) {
    VisualNode.fillRect( outputBoxPosition,
			 node.outputColor,
			 graphics )
  }

  /**
   * Paints all the input and output lines of this node
   * @@param graphics The graphics object to paint with
   */
  def paintLines( graphics: Graphics ) {
    paintInputLines( graphics )
    paintOutputLine( graphics )
  }

  /**
   * Paints out this node.  Note that this only refers to the
   * node itself, not to anything that it is connected to.
   * @@param graphics The graphics object to paint with
   */
  def paintNode( graphics: Graphics ) {
    paintNodeBase( graphics )
    paintLines( graphics )
    paintText( graphics )
  }

  /**
   * Paints the text label of a node.
   * @@param graphics The graphics object to paint with
   */
  def paintText( graphics: Graphics ) {
    val ( xPos,
	  yPos ) = topLeftCorner
    VisualNode.drawString( label,
			   xPos + VisualNode.DRAW_TEXT_WIDTH_ADD,
			   yPos + height + VisualNode.DRAW_TEXT_HEIGHT_ADD,
			   width - VisualNode.DRAW_TEXT_WIDTH_ADD,
			   graphics )
  }

  /**
   * Given a node and an x and y coordinate, it returns whether or
   * not the output line was selected.  Assumes that the x and y
   * coordinates are within the node
   * @@pre The given x and y coordinate are in the node
   * @@param x The x coordinate of selection
   * @@param y The y coordinate of selection
   * @@return true if the output line was selected, else false
   */
  def outputLineSelected( x: Int, y: Int ) = {
    val ( topLeft,
	  bottomRight ) = outputBoxPosition
    VisualNode.pointWithin( Pair( x, y ),
			    topLeft,
			    bottomRight )
  }

  /**
   * Given an x, y coordinate, returns the name of the
   * input that was selected.
   * @@pre The x, y coordinate is within this node
   * @@param x The x coordinate
   * @@param y The y coordinate
   * @@return The name of the input that was selected, or None
   * if no inputs were selected
   */
  def selectedInput( x: Int, y: Int ) = {
    val point = Pair( x, y )
    val inputPositions = inputBoxPositions.toArray
    var inputNumber = 0
    var retval: Option[ String ] = None
    var done = false

    while( inputNumber < inputPositions.length &&
	   !done ) {
      val ( topLeftInput,
	    bottomRightInput ) = inputPositions( inputNumber )
      if ( VisualNode.pointWithin( point,
				   topLeftInput,
				   bottomRightInput ) ) {
	retval = Some( node.inputNumberToName( inputNumber ) )
	done = true
      }
      inputNumber += 1
    }

    retval
  }

  /**
   * Given an x, y coordinate, returns which line was selected.
   * @@pre The x, y coordinate is within this node
   * @@param x The x coordinate
   * @@param y The y coordinate
   * @@return The name of the input that was selected, or OUTPUT_LINE if
   * the output was selected, or None if no lines were selected
   */
  def selectedLine( x: Int, y: Int ) = 
    if ( outputLineSelected( x, y ) ) {
      Some( Node.OUTPUT_LINE )
    } else {
      selectedInput( x, y )
    }
}

/**
 * A special visual node just for debugging.
 * @@param debugNode The node that underlies this one
 * @@param board The board that the node is on
 * @@author Kyle Dewey
 */
class DebuggingNode( val debugNode: SentinelDebuggingNode,
		     board: NodeBoard[ InstanceFactory[ _ ], Param ] )
extends VisualNode( debugNode, board, debugNode.variable.variable ) {
  /**
   * Resets the value of this node to a default value.
   * This value is <code>SentinelDebuggingNode.DEFAULT_VARIABLE_VALUE</code>
   */
  def reset(): Unit =
    label = SentinelDebuggingNode.DEFAULT_VARIABLE_VALUE

  /**
   * Gets the value of the label.
   * @@return The value of the label
   */
  override def label =
    debugNode.variable.variable

  /**
   * Sets the value of the label
   * @@param newLabel The new value of the label
   */
  override def label_=( newLabel: String ): Unit =
    debugNode.variable.variable = newLabel
}

@


1.5
log
@Added the sortNodes() method.
@
text
@d5 1
a5 1
 *     $Id: VisualNode.scala,v 1.4 2011/02/27 22:33:07 kyledewey Exp $
d9 3
d619 1
a619 1
extends VisualNode( debugNode, board, debugNode.variable.cellValue ) {
d632 1
a632 1
    debugNode.variable.cellValue
d639 1
a639 1
    debugNode.variable.cellValue = newLabel
@


1.4
log
@Moved disconnect() routine in the singleton object
to a method in Node.
@
text
@d5 1
a5 1
 *     $Id: VisualNode.scala,v 1.3 2011/02/27 04:29:17 kyledewey Exp $
d9 4
d63 2
a64 2
			    board: NodeBoard[ T, U ],
			    label: String ): VisualNode[ T, U ] = {
d359 10
@


1.3
log
@Refactored for use with debuggers.
@
text
@d5 1
a5 1
 *     $Id: VisualNode.scala,v 1.2 2011/02/26 04:14:03 kyledewey Exp kyledewey $
d9 3
a39 3
  // special string representing the output of a node
  val OUTPUT_LINE = "output"

a322 14
   * Given a node and an input/output line, it will perform
   * a disconnection operation
   * @@param node The node
   * @@param line The input/output line to disconnect
   */
  def disconnect( node: Node[ _, _ ], line: String ) {
    if ( line.eq( OUTPUT_LINE ) ) {
      node.disconnectOutput()
    } else {
      node.disconnectInput( line )
    }
  }

  /**
d588 1
a588 1
      Some( VisualNode.OUTPUT_LINE )
d604 7
@


1.2
log
@No longer a JComponent.  Added code for handling
debugging tools.
@
text
@d5 1
a5 1
 *     $Id: VisualNode.scala,v 1.1 2011/02/25 20:56:03 kyledewey Exp kyledewey $
d9 4
a48 3
  // debugger class name
  val DEBUGGER_CLASS = "sentinel.model.replacer.Debugger"

d58 3
a60 3
  def apply[ T <: AnyRef ]( node: Node[ T ],
			    board: NodeBoard[ T ],
			    label: String ): VisualNode[ T ] = {
d64 6
a69 9
      case n: SentinelNode =>
	n.factory match {
	  case f: ReflectionFactory[ _ ] if ( f.JVMClassName == DEBUGGER_CLASS ) =>
	    new DebuggingNode( n, board.asInstanceOf[ NodeBoard[ InstanceFactory[ _ ] ] ] )
	  case _ =>
	    new VisualNode[ T ]( n, board, n.factory.name )
	}
      case _ => 
	new VisualNode[ T ]( node, board, label )
d72 1
d328 1
a328 1
  def disconnect( node: Node[ _ ], line: String ) {
d382 17
a398 3
class VisualNode[ T <: AnyRef ]( val node: Node[ T ],
			         val board: NodeBoard[ T ],
				 var label: String ) {
d610 1
a610 1
 * @@param sentinelNode The node that underlies this one
d614 16
a629 3
class DebuggingNode( val sentinelNode: SentinelNode,
		     board: NodeBoard[ InstanceFactory[ _ ] ] )
extends VisualNode( sentinelNode, board, "MR DEBUG" ) {
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d17 1
d36 38
d94 56
d336 34
d376 2
a377 2
 * no code for painting connections.  Connections must be painted last, and there
 * is no good way of enforcing this from the perspective of a single node.
d379 2
d383 3
a385 2
abstract class VisualNode[ T <: AnyRef ]( val node: Node[ T ] ) 
extends JComponent {
d390 2
a391 1
  def topLeftCorner(): Pair[ Int, Int ]
d397 1
a397 1
  def width(): Int
d403 1
a403 1
  def height(): Int
d513 1
d517 1
a517 1
   * Paints this node
d520 8
a527 3
  override def paintComponent( graphics: Graphics ) {
    super.paintComponent( graphics )
    paintNode( graphics )
d596 2
a597 2
 * A visual node that is on a NodeBoard.
 * @@param node The node
d601 4
a604 9
class VisualNodeOnBoard[ T <: AnyRef ]( node: Node[ T ],
				        val board: NodeBoard[ T ] ) 
extends VisualNode[ T ]( node ) {
  /**
   * Gets the top left corner of this node.
   * @@return The top left corner of this node
   */
  override def topLeftCorner() =
    board.getCorner( node ).get
a605 14
  /**
   * Gets the width of this node
   * @@return The width of this node
   */
  override def width() =
    board.getWidth( node )

  /**
   * Gets the height of this node
   * @@return The height of this node
   */
  override def height() =
    board.compHeight
}
@
