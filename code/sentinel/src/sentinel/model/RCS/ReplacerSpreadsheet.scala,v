head	1.12;
access;
symbols;
locks
	kyledewey:1.12; strict;
comment	@# @;


1.12
date	2011.06.02.06.55.38;	author kyledewey;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.01.03.58.30;	author kyledewey;	state Exp;
branches;
next	1.10;

1.10
date	2011.05.31.20.22.20;	author kyledewey;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.29.22.11.57;	author kyledewey;	state Exp;
branches;
next	1.8;

1.8
date	2011.05.28.02.37.45;	author kyledewey;	state Exp;
branches;
next	1.7;

1.7
date	2011.05.27.18.48.02;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2011.05.27.01.32.13;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.26.18.49.27;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.25.20.04.57;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2011.02.12.01.48.48;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.07.17.02.04.01;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.11.05.44.00;	author kyledewey;	state Exp;
branches;
next	;


desc
@A spreadsheet with replacer functionality.
@


1.12
log
@Added the getInstances() method.
@
text
@/*
 * ReplacerSpreadsheet.scala
 *
 * Version:
 *     $Id: ReplacerSpreadsheet.scala,v 1.11 2011/06/01 03:58:30 kyledewey Exp $
 *
 * Revisions:
 *      $Log: ReplacerSpreadsheet.scala,v $
 *      Revision 1.11  2011/06/01 03:58:30  kyledewey
 *      Removed the boolean parameter from executeGoodData().
 *      With the current InstanceResult design, there isn't
 *      an appropriate value to pass when all is false
 *      and none of the matchers succeeded.
 *
 *      Revision 1.10  2011/05/31 20:22:20  kyledewey
 *      Added boolean parameter to executeGoodData().
 *
 *      Revision 1.9  2011/05/29 22:11:57  kyledewey
 *      Removed the remove* methods.
 *      Added the clear* methods.
 *
 *      Revision 1.8  2011/05/28 02:37:45  kyledewey
 *      Moved mapFind to sentinel.model.SentinelHelpers.
 *
 *      Revision 1.7  2011/05/27 18:48:02  kyledewey
 *      Now uses Spreadsheet's updateCurrent() method.
 *
 *      Revision 1.6  2011/05/27 01:32:13  kyledewey
 *      Now uses Spreadsheet's copyContents() method.
 *
 *      Revision 1.5  2011/05/26 18:49:27  kyledewey
 *      Refactored to allow extension with custom instantiators.
 *
 *      Revision 1.4  2011/05/25 20:04:57  kyledewey
 *      Major refactor.  The model used by ReplacerSpreadsheets
 *      is now based on that from ErrorChecker.pl.  That is,
 *      each cell has 0-N good data matchers, and 0-N matcher/replacer
 *      pairs.
 *
 *      Revision 1.3  2011/02/12 01:48:48  kyledewey
 *      Changed implementation of DefaultReplacerSpreadsheet.
 *
 *      Revision 1.2  2010/07/17 02:04:01  kyledewey
 *      Refactored spreadsheet hierarchy so that Spreadsheet and
 *      ReplacerSpreadsheet are both traits instead of classes.
 *
 *      Revision 1.1  2010/07/11 05:44:00  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model

import java.util.Vector
import javax.swing.table.TableModel

/**
 * Contains helper methods and convenience methods for ReplaceSpreadsheet
 * @@author Kyle Dewey
 */
object ReplacerSpreadsheet {
  import Spreadsheet._

  /**
   * Creates a new ReplacerSpreadheet with the given name
   * @@param name The name of the spreadsheet
   * @@param register If we should register it or not
   * @@return A new, empty spreadsheet
   * @@throws SpreadsheetNameException If the name of the spreadsheet isn't
   * valid
   */
  def apply( name: String, register: Boolean ) =
    DefaultReplacerSpreadsheet( name, register )

  /**
   * Creates a new ReplacerSpreadsheet from another spreadsheet.
   * Note that error correction is NOT performed.
   * @@param sheet The sheet to promote from
   * @@param register If we should register or not
   * @@return A new ReplacerSpreadsheet, containing all the information in
   * the old spreadsheet.  Also returns a parallel matrix of error
   * correction results, but only if error correction is on
   * @@throws SpreadsheetNameException If the name of the spreadsheet isn't
   * valid
   */
  def apply( sheet: Spreadsheet, 
	     register: Boolean ): DefaultReplacerSpreadsheet[ NonDataCellContents ] = 
    Spreadsheet.copyContents( sheet, apply( sheet.name, register ) )

  /**
   * Like CellRange's foreach, but it only considers ReplacerSpreadsheets.
   * @@param cellRange The cell range to go over
   * @@param function The function to call on the given range
   */
  def foreach( cellRange: CellRange,
	       function: ( ReplacerSpreadsheet, Int, Int ) => Unit ) {
    cellRange.foreach( ( sheet, row, column ) => {
      val spreadsheet = getSpreadsheet( sheet )
      if ( spreadsheet.isInstanceOf[ ReplacerSpreadsheet ] ) {
	function( spreadsheet.asInstanceOf[ ReplacerSpreadsheet ],
		  row, column )
      }
    })
  }

  /**
   * Sets all spreadsheets in the given range to have the given
   * "Good Data" matcher
   * Note that any sheets must be registered.
   * @@param range The cell range to execute over
   * @@param matcher The matcher to add
   */
  def addGoodDataMatcher( range: CellRange,
			  matcher: Matcher ) {
    foreach( range,
	     ( sheet, row, column ) =>
	       sheet.addGoodDataMatcher( row, column, matcher ) )
  }
    
  /**
   * Sets all spreadsheets in the given range to have the given
   * "Error Correction" matcher/replacer pair
   * @@param range The cell range to execute over
   * @@param pair The pair to add
   */
  def addErrorCorrectionPair( range: CellRange,
			      pair: Pair[ Matcher, Replacer ] ) {
    foreach( range,
	     ( sheet, row, column ) =>
	       sheet.addErrorCorrectionPair( row, column, pair ) )
  }

  /**
   * Gets the given replacer spreadsheet, if it exists.
   * @@param name The name of the replacer spreadsheet
   * @@return The replacer spreadsheet, or None if the sheet doesn't
   * exist or if the sheet is not a replacer spreadsheet
   */
  def getSpreadsheet( name: String ) = {
    val sheet = Spreadsheet.getSpreadsheet( name )
    if ( sheet.isDefined &&
	 sheet.get.isInstanceOf[ ReplacerSpreadsheet ] ) {
      Some( sheet.get.asInstanceOf[ ReplacerSpreadsheet ] )
    } else None
  }
}

/**
 * Describes a table model that can optionally choose to put a value
 * in for a given position.
 * @@author Kyle Dewey
 */
trait ConditionalSpreadsheet extends Spreadsheet {
  /**
   * Temporarily sets a value at the given position, and tests it against
   * any error correction facilities for the cell.  Note that this will
   * not actually set the value; once the call completes the value will
   * have reverted to the original value.
   * @@param item The item to put here
   * @@param row The row to set at
   * @@param column The column to set at
   * @@return An instance result describing what happened
   * @@throws ArrayIndexOutOfBoundsException If the given row, column pair
   * points to an invalid location in the spreadsheet
   */
  def tryValueAt( item: String, row: Int, column: Int ): Option[ InstanceResult ]
}

/**
 * Represents a spreadsheet that has matchers and replacers in it.
 * There are two important concepts here: the "Good Data" matchers and
 * "Error Correction" matcher/replacer pairs.
 * <p>A cell can have 0-N "Good Data" matchers associated with it.  These
 * are used to validate that data is valid.  If all return true, then
 * the data is considered valid.  If there are none associated, the data is
 * considered valid.  If at least one returns false, the data is considered
 * erroneous.  Note tht the behavior is short circuiting: the first that
 * returns false will prevent the others from being executed. Also
 * note that exceptions are considered the same as false values.</p>
 * <p>A cell can have 0-N "Error Correction" matcher/replacer pairs. If
 * all the "Good Data" matchers return true, these are irrelevant.  If not,
 * execution passes to these.  These are run through, one at a time, executing
 * the matchers.  For the first matcher that matches, the matcher's
 * associated replacer is executed.  That replacer's returned result is
 * intended to be used as an error correction value. As to how exactly
 * that value is used depends on whether or not this is run interactively,
 * so at this level of the class hierarchy nothing is done beyond returning
 * that result.  If the replacer throws an exception, it is considered an
 * uncorrectable error.  If the "Good Data" matchers had at least one failure,
 * and there are no "Error Correction" matcher/replacer pairs, it is considered
 * an uncorrectable error.  If the "Good Data" matchers had at least one
 * failure and no "Error Correction" matchers matched, it is considered
 * an uncorrectable error. Note that if a matcher throws an exception,
 * it is considered to have returned false.</p>
 * @@author Kyle Dewey
 */
trait ReplacerSpreadsheet extends ConditionalSpreadsheet {
  import InstanceResult._

  /**
   * Adds a "Good Data" matcher to the given cell.
   * If the matcher is already associated, this is a no-op
   * @@param row The row for the matcher
   * @@param column The column for the matcher
   * @@param matcher The matcher to put here
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def addGoodDataMatcher( row: Int, column: Int, matcher: Matcher ): Unit

  /**
   * Gets all the "Good Data" matchers for the given cell.
   * Returns them in the order that they were put in there.
   * @@param row The row for the matcher
   * @@param column The column for the matcher
   * @@return All the "Good Data" matchers at this cell
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def getGoodDataMatchers( row: Int, column: Int ): Seq[ Matcher ]

  /**
   * Adds an "Error Correction" matcher, replacer pair to the given cell.
   * If it is already associated, this is a no-op.
   * @@param row The row
   * @@param column The column
   * @@param pair The matcher/replacer pair
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def addErrorCorrectionPair( row: Int, 
			      column: Int, 
			      pair: Pair[ Matcher, Replacer ] ): Unit

  /**
   * Gets all "Error Correction" matcher, replacer pairs associated with
   * the given cell.  Gets them in the order they were added.
   * @@param row The row
   * @@param column The columm
   * @@returns All "Error Correction" matcher/replacer pairs associated with
   * the given cell, in the order which they were associated
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def getErrorCorrectionPairs( row: Int, 
			       column: Int ): Seq[ Pair[ Matcher, Replacer ] ]

  /**
   * Gets all instances directly connected to the given cell.
   * This means all good data matchers, and all matcher/replacer
   * error correction pairs.
   * @@param row The row
   * @@param column The column
   * @@return All instances here
   */
  def getInstances( row: Int, column: Int ): Seq[ Instance ] =
    getGoodDataMatchers( row, column ) ++ getErrorCorrectionPairs( row, column ).flatMap( pair => Seq( pair._1, pair._2 ) )

  /**
   * Clears out good data matchers from the given cell.
   * @@param row The row of the cell
   * @@param column The column of the cell
   */
  def clearGoodData( row: Int, column: Int ): Unit

  /**
   * Clears out the error correction pairs from the given cell
   * @@param row The row of the cell
   * @@param column the column of the cell
   */
  def clearErrorCorrectionPairs( row: Int, column: Int ): Unit

  /**
   * Executes all "Good Data" matchers at the given row and column.
   * Returns an InstanceResult describing what happened.  Note that
   * throwing an exception is considered the same as being false
   * @@param row The row
   * @@param column The column
   * @@return An InstanceResult describing what happened.
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def executeGoodData( row: Int, column: Int ): InstanceResult = 
    SentinelHelpers.mapFind( getGoodDataMatchers( row, column ),
			     ( m: Matcher ) => executeMatcher( m ),
			     ( i: InstanceResult ) => i.failure )
                   .getOrElse( new InstanceSuccess() )

  /**
   * Executes any error correction pairs for the given row and column.
   * Returns an InstanceResult describing what happened for the replacer
   * executed on the first matching matcher, or None if none of the
   * error correction pairs matched.
   * @@param row The row
   * @@param column The column
   * @@return An InstanceResult describing what happened for the first matching
   * replacer, or None if none of the replacers matched
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def executeErrorCorrectionPairs( row: Int, column: Int ) =
    SentinelHelpers.mapFind( getErrorCorrectionPairs( row, column ),
			     ( p: Pair[ Matcher, Replacer ] ) =>
			       executeErrorCorrectionPair( p ),
			     ( result: Option[ InstanceFailure[ Replacer ] ] ) =>
			       result.isDefined )
                   .getOrElse( None )
  
  /**
   * Sets the value at the given position, and runs it through
   * the "GoodData" matchers and the "Error Correction" matcher/replacer
   * pairs.
   * @@param value The value to try to put here
   * @@param row The row to put it at
   * @@param column The column to put it at
   * @@return One of the following: <table border="1">
   * <tr><th>Return Value</th><th>Meaning</th></tr>
   * <tr><td>Some( InstanceSuccess )</td><td>The data was considered valid by the
   * "Good Data" matchers</td></tr>
   * <tr><td>Some( InstanceFailureException )</td><td>The data was considered invalid,
   * and the replacer for the first matching error correction pair threw an exception
   * </td></tr>
   * <tr><td>Some( InstanceFailureReplacement )</td><td>The data was considered invalid,
   * and the replacer for the first matching error correction pair returned a replacement
   * </td></tr>
   * <tr><td>None</td><td>The data was considered invalid, but no error correction pair
   * matched</td></tr></table>
   * @@throws ArrayIndexOutOfBoundsException If the given row, column pair
   * points to an invalid location in the spreadsheet
   */
  def tryValueAt( value: String, row: Int, column: Int ) = {
    val oldValue = getValueAt( row, column )
    setValueAt( value, row, column )
    updateCurrent( row, column )
    val goodDataResult = executeGoodData( row, column )
    val retval =
      if ( goodDataResult.success ) {
	Some( goodDataResult )
      } else {
	executeErrorCorrectionPairs( row, column )
      }
    setValueAt( oldValue, row, column )
    retval
  }
} // ReplacerSpreadsheet

import scala.collection.mutable.ArrayBuffer

/**
 * Simple container class for simplifying <code>DefaultReplacerSpreadsheet</code>.
 * Holds all the non-data for each cell.
 * @@param goodDataMatchers The "Good Data" matchers to use for a cell
 * @@param errorCorrectionPairs The "Error Correction" matcher/replacer pairs for a cell
 * @@author Kyle Dewey
 */
class NonDataCellContents( val goodDataMatchers: SeqSet[ Matcher ],
			   val errorCorrectionPairs: SeqSet[ Pair[ Matcher, Replacer ] ] ){
  /**
   * Creates a new contents that doesn't actually hold anything
   */
  def this() =
    this( new SeqSet(),
	  new SeqSet() )

  /**
   * Adds a good data matcher to this
   * If it's a repeat, this is a no-op
   * @@param matcher The matcher to add
   */
  def addGoodData( matcher: Matcher ) {
    goodDataMatchers.addItem( matcher )
  }

  /**
   * Adds an error correction pair to this
   * @@param pair The pair to add
   */
  def addErrorCorrection( pair: Pair[ Matcher, Replacer ] ) {
    errorCorrectionPairs.addItem( pair )
  }

  /**
   * Clears the good data.
   */
  def clearGoodData() {
    goodDataMatchers.clear()
  }

  /**
   * Clears the error correction pairs
   */
  def clearErrorCorrection() {
    errorCorrectionPairs.clear()
  }
}

/**
 * Contains routines for making DefaultReplacerSpreadsheets
 * @@author Kyle Dewey
 */
object DefaultReplacerSpreadsheet {
  /**
   * Creates a new default replacer spreadsheet.
   * @@param name The name of the spreadsheet
   * @@param register Whether or not to register the spreadsheet
   * @@param instantiator What to use for lazy instantiation of cells
   * @@return A new DefaultReplacerSpreadsheet made with the given params
   */
  def apply[ T <: NonDataCellContents ]( name: String, register: Boolean, instantiator: ( Int, Int ) => T ): DefaultReplacerSpreadsheet[ T ] = 
    new DefaultReplacerSpreadsheet[ T ]( name, register, instantiator )

  /**
   * Creates a new default replacer spreadsheet that
   * uses the base class of NonDataCellContents.
   * @@param name The name of the spreadsheet
   * @@param register Whether or not to register the spreadsheet
   * @@return A new DefaultReplacerSpreadsheet that uses the given params
   * and uses the base class of NonDataCellContents
   */
  def apply( name: String, register: Boolean ): DefaultReplacerSpreadsheet[ NonDataCellContents ] =
    apply( name, register, ( row: Int, column: Int ) => new NonDataCellContents() )
}
					   
/**
 * Implementation of ReplacerSpreadsheet that maintains a parallel matrix of
 * "Good Data" matchers and "Error Correction" 
 * @@param name The name of the spreasheet
 * @@param register If we should register this spreadsheet
 * @@param instantiator Creates a new empty NonDataCellContents object
 * on demand
 * @@throws SpreadsheetNameException if the name of the spreadshet is
 * invalid
 * @@author Kyle Dewey
 */
class DefaultReplacerSpreadsheet[ T <: NonDataCellContents ]
( name: String, register: Boolean, instantiator: ( Int, Int ) => T )
extends LazyParallelSpreadsheet[ T ]( name, register, instantiator ) with ReplacerSpreadsheet {
  /**
   * Adds a "Good Data" matcher to the given cell.
   * If the matcher is already associated, this is a no-op
   * @@param row The row for the matcher
   * @@param column The column for the matcher
   * @@param matcher The matcher to put here
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def addGoodDataMatcher( row: Int, column: Int, matcher: Matcher ) {
    getInstantiatedDataAt( row, column ).addGoodData( matcher )
  }

  /**
   * Gets all the "Good Data" matchers for the given cell.
   * Returns them in the order that they were put in there.
   * @@param row The row for the matcher
   * @@param column The column for the matcher
   * @@return All the "Good Data" matchers at this cell
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def getGoodDataMatchers( row: Int, column: Int ) =
    getInstantiatedDataAt( row, column ).goodDataMatchers.asSeq

  /**
   * Adds an "Error Correction" matcher, replacer pair to the given cell.
   * If it is already associated, this is a no-op.
   * @@param row The row
   * @@param column The column
   * @@param pair The matcher/replacer pair
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def addErrorCorrectionPair( row: Int, 
			      column: Int, 
			      pair: Pair[ Matcher, Replacer ] ) {
    getInstantiatedDataAt( row, column ).addErrorCorrection( pair )
  }

  /**
   * Gets all "Error Correction" matcher, replacer pairs associated with
   * the given cell.  Gets them in the order they were added.
   * @@param row The row
   * @@param column The columm
   * @@returns All "Error Correction" matcher/replacer pairs associated with
   * the given cell, in the order which they were associated
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def getErrorCorrectionPairs( row: Int, column: Int ) =
    getInstantiatedDataAt( row, column ).errorCorrectionPairs.asSeq

  /**
   * Clears out good data matchers from the given cell.
   * @@param row The row of the cell
   * @@param column The column of the cell
   */
  def clearGoodData( row: Int, column: Int ) {
    getInstantiatedDataAt( row, column ).clearGoodData()
  }

  /**
   * Clears out the error correction pairs from the given cell
   * @@param row The row of the cell
   * @@param column the column of the cell
   */
  def clearErrorCorrectionPairs( row: Int, column: Int ) {
    getInstantiatedDataAt( row, column ).clearErrorCorrection()
  }
} // DefaultReplacerSpreadsheet
@


1.11
log
@Removed the boolean parameter from executeGoodData().
With the current InstanceResult design, there isn't
an appropriate value to pass when all is false
and none of the matchers succeeded.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.10 2011/05/31 20:22:20 kyledewey Exp kyledewey $
d9 6
d246 11
@


1.10
log
@Added boolean parameter to executeGoodData().
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.9 2011/05/29 22:11:57 kyledewey Exp $
d9 3
a258 2
   * @@param all True if all matchers must match.  If it's false, we declare
   * success once we encounter one that matches.
d262 1
a262 8
  def executeGoodData( row: Int, column: Int, all: Boolean ): InstanceResult = {
    val terminator: InstanceResult => Boolean =
      if ( all ) {
	_.failure
      } else {
	_.success
      }

d265 1
a265 1
			     terminator )
a266 12
  }

  /**
   * Like <code>executeGoodData</code>, only <code>all</code> is set
   * to <code>false</code>.
   * @@param row The row
   * @@param column The column
   * @@return An instance result describing what happened
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def executeGoodData( row: Int, column: Int ): InstanceResult =
    executeGoodData( row, column, false )
@


1.9
log
@Removed the remove* methods.
Added the clear* methods.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.8 2011/05/28 02:37:45 kyledewey Exp $
d9 4
d256 2
d261 8
a268 1
  def executeGoodData( row: Int, column: Int ) =
d271 1
a271 1
			     ( result: InstanceResult ) => result.failure )
d273 13
a285 1
  
@


1.8
log
@Moved mapFind to sentinel.model.SentinelHelpers.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.7 2011/05/27 18:48:02 kyledewey Exp $
d9 3
a198 10
   * Removes the given "Good Data" matcher from the given cell.
   * If there isn't one here, this is a no-op
   * @@param row The row
   * @@param column The column
   * @@param matcher The matcher to remove
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def removeGoodDataMatcher( row: Int, column: Int, matcher: Matcher ): Unit

  /**
a220 12
   * Removes an "Error Correction" matcher, replacer pair from the given cell.
   * If it is not associated, this is a no-op.
   * @@param row The row
   * @@param column The column
   * @@param pair The matcher/replacer pair
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def removeErrorCorrectionPair( row: Int, 
				 column: Int, 
				 pair: Pair[ Matcher, Replacer ] ): Unit

  /**
d233 14
d334 1
a334 1
	 new SeqSet() )
d346 2
a347 2
   * Removes the given good data matcher from this
   * @@param matcher The matcher to remove
d349 2
a350 2
  def removeGoodData( matcher: Matcher ) {
    goodDataMatchers.removeItem( matcher )
d354 1
a354 2
   * Adds an error correction pair to this
   * @@param pair The pair to add
d356 2
a357 2
  def addErrorCorrection( pair: Pair[ Matcher, Replacer ] ) {
    errorCorrectionPairs.addItem( pair )
d361 1
a361 2
   * Removes an error correction pair from this
   * @@param pair The pair to remove
d363 2
a364 2
  def removeErrorCorrection( pair: Pair[ Matcher, Replacer ] ) {
    errorCorrectionPairs.removeItem( pair )
a421 12
   * Removes the given "Good Data" matcher from the given cell.
   * If there isn't one here, this is a no-op
   * @@param row The row
   * @@param column The column
   * @@param matcher The matcher to remove
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def removeGoodDataMatcher( row: Int, column: Int, matcher: Matcher ) {
    getInstantiatedDataAt( row, column ).removeGoodData( matcher )
  }

  /**
a446 14
   * Removes an "Error Correction" matcher, replacer pair from the given cell.
   * If it is not associated, this is a no-op.
   * @@param row The row
   * @@param column The column
   * @@param pair The matcher/replacer pair
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def removeErrorCorrectionPair( row: Int, 
				 column: Int, 
				 pair: Pair[ Matcher, Replacer ] ) {
    getInstantiatedDataAt( row, column ).removeErrorCorrection( pair )
  }

  /**
d457 18
@


1.7
log
@Now uses Spreadsheet's updateCurrent() method.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.6 2011/05/27 01:32:13 kyledewey Exp kyledewey $
d9 3
a118 22
   * Like a find, but it maps the given element beforehand.  It will return
   * the mapped element, or None if there wasn't one.
   * @@param seq The sequence
   * @@param map The mapping function
   * @@param pred The predicate to use on the result of the map
   * @@return The first mapped element for which pred( map( element ) ) was
   * true, or None if there wasn't one
   */
  def mapFind[ E, M ]( seq: Seq[ E ], map: E => M, pred: M => Boolean ) = {
    var retval: Option[ M ] = None
    seq.find( element => {
      val mapped = map( element )
      val findResult = pred( mapped )
      if ( findResult ) {
	retval = Some( mapped )
      }
      findResult
    })
    retval
  }

  /**
d261 4
a264 4
    ReplacerSpreadsheet.mapFind( getGoodDataMatchers( row, column ),
				 ( m: Matcher ) => executeMatcher( m ),
				 ( result: InstanceResult ) => result.failure )
                       .getOrElse( new InstanceSuccess() )
d278 6
a283 6
    ReplacerSpreadsheet.mapFind( getErrorCorrectionPairs( row, column ),
				 ( p: Pair[ Matcher, Replacer ] ) =>
				   executeErrorCorrectionPair( p ),
				 ( result: Option[ InstanceFailure[ Replacer ] ] ) =>
				   result.isDefined )
                       .getOrElse( None )
@


1.6
log
@Now uses Spreadsheet's copyContents() method.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.5 2011/05/26 18:49:27 kyledewey Exp kyledewey $
d9 3
d329 1
a329 3
    Spreadsheet.currentSpreadsheet = name
    Spreadsheet.currentRow = row
    Spreadsheet.currentColumn = column
@


1.5
log
@Refactored to allow extension with custom instantiators.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.4 2011/05/25 20:04:57 kyledewey Exp $
d9 3
d66 2
a67 6
	     register: Boolean ): DefaultReplacerSpreadsheet[ NonDataCellContents ] = {
    val retval = apply( sheet.name, register )
    retval.setDataVector( sheet.getDataVector,
		          sheet.getColumnIdentifiers )
    retval
  }
@


1.4
log
@Major refactor.  The model used by ReplacerSpreadsheets
is now based on that from ErrorChecker.pl.  That is,
each cell has 0-N good data matchers, and 0-N matcher/replacer
pairs.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.3 2011/02/12 01:48:48 kyledewey Exp $
d9 6
d49 1
a49 1
    new DefaultReplacerSpreadsheet( name, register )
d63 1
a63 1
	     register: Boolean ): DefaultReplacerSpreadsheet = {
d157 4
a160 2
   * Sets the value at the given position, but only if the value is valid
   * for the given cell.  If it isn't valid, it will say why.
d164 1
a164 2
   * @@return A replacement result describing what happened, or None if
   * we couldn't narrow it down to a single result
d395 27
d426 2
d432 3
a434 3
class DefaultReplacerSpreadsheet( name: String, register: Boolean )
extends LazyParallelSpreadsheet[ NonDataCellContents ]( name, register, ( row: Int, column: Int ) => new NonDataCellContents() ) with ReplacerSpreadsheet {

@


1.3
log
@Changed implementation of DefaultReplacerSpreadsheet.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.2 2010/07/17 02:04:01 kyledewey Exp kyledewey $
d9 3
a27 14
 * An enumeration describing the various possibilites for replacing
 * a value of the spreadsheet.
 * @@author Kyle Dewey
 */
object ReplacementResult extends Enumeration {
  type ReplacementResult = Value
  val NoError, // the data was inserted without modification
      AutoCorrected,  // the data was inserted with modification
      Uncorrectable = Value // the data was erroneous with no correction
}

import ReplacementResult._

/**
d32 2
d37 1
d42 2
a43 2
  def apply( name: String ) =
    new DefaultReplacerSpreadsheet( name )
d49 1
d56 3
a58 2
  def apply( sheet: Spreadsheet ): DefaultReplacerSpreadsheet = {
    val retval = apply( sheet.name )
d65 77
a141 7
   * Determines if the given error correction row has an
   * uncorrectable row in it
   * @@param rowResults The results of error correction on the row
   * @@return true if there is an uncorrectable row in the output, else false
   */
  def containsUncorrectable( rowResults: Seq[ Pair[ ReplacementResult, Option[ String ] ] ] ) =
    !rowResults.filter( _._1 == Uncorrectable ).isEmpty
d156 2
a157 2
   * @@return A replacement result describing what happened, along with
   * a possible description message of why it happened
d161 1
a161 3
  def tryValueAt( item: Object, 
		  row: Int, 
		  column: Int ): Pair[ ReplacementResult, Option[ String ] ]
d165 25
a189 2
 * Represents a spreadsheet that has replacers in it.  A single cell
 * can have at most one replacer associated with it.
d193 2
d196 5
a200 5
   * Sets that a specific replacer is supposed to cover the given cell.
   * If a replacer is already there, then this overwrites it
   * @@param row The row for the replacer
   * @@param column The column for the replacer
   * @@param replacer The replacer to put here
d203 1
a203 1
  def setReplacerAt( row: Int, column: Int, replacer: Replacer ): Unit
d206 8
a213 8
   * Gets the replacer for a specific cell
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return The replacer at this position, or None if there was no
   * replacer here
   * @@throws IndexOutOfBoundsException if the given position doesn't exist
   */ 
  def getReplacerAt( row: Int, column: Int ): Option[ Replacer ]
d216 5
a220 4
   * Determines if there is a replacer at the given position
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return true If there is a replacer here, else false
d223 1
a223 2
  def isReplacerAt( row: Int, column: Int ) =
    getReplacerAt( row, column ).isDefined 
d226 6
a231 3
   * Sets that the given replacer is supposed to cover the whole sheet.
   * This correlates to *:*
   * @@param replacer The replacer to cover the sheet with
d233 3
a235 5
  def setSheetReplacer( replacer: Replacer ) {
    ( 0 to getRowCount - 1 ).foreach( row =>
      ( 0 to getColumnCount - 1 ).foreach( column =>
	setReplacerAt( row, column, replacer ) ) )
  }
d238 6
a243 5
   * Sets that the given replacer is supposed to cover the given row.
   * This correlates to 123:*
   * @@param row The row to cover
   * @@param replacer The replacer to cover the row with
   * @@throws IndexOutOfBoundsException If the given row doesn't exist
d245 3
a247 4
  def setRowReplacer( row: Int, replacer: Replacer ) {
    ( 0 to getColumnCount - 1 ).foreach( column =>
      setReplacerAt( row, column, replacer ) )
  }
d250 7
a256 5
   * Sets that the given replacer is supposed to cover the given column.
   * This correlates to *:123
   * @@param column The column to cover
   * @@param replacer The replacer to cover the column with
   * @@throws IndexOutOfBoundsException If the given column doesn't exist
d258 2
a259 4
  def setColumnReplacer( column: Int, replacer: Replacer ) {
    ( 0 to getRowCount - 1 ).foreach( row =>
      setReplacerAt( row, column, replacer ) )
  }
d262 6
a267 7
   * Sets the replacer at the given position, but only if the position
   * is not already occupied with a replacer
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@param replacer The replacer to put here
   * @@return true if the replacer was inserted, else false, meaning that
   * a replacer was already here
d270 6
a275 7
  def setReplacerAtIfEmpty( row: Int, column: Int, replacer: Replacer ) = {
    if ( !isReplacerAt( row, column ) ) {
      setReplacerAt( row, column, replacer )
      true
    } else false
  }

d277 9
a285 5
   * Performs error correction on the given row.
   * Note that uncorrectable errors will remain in the spreadsheet, though
   * autocorrected data will replace old data.
   * @@param row The row to perform error correction on
   * @@return The error correction results of the given row
d287 7
a293 10
  def errorCorrection( row: Int ) =
    // MAJOR GOTCHA
    // without the .force, the error correction rules
    // would be evaulated every time calling code attempts to see the
    // result.  That is, every time the result is used, the error
    // correction language is executed again!
    ( 0 to getColumnCount - 1 ).map( column =>
      tryValueAt( getValueAt( row, column ),
		  row,
		  column ) ).force
d296 18
a313 37
   * Performs error correction on the entire spreadsheet.
   * Note that this is very computationally expensive, for obvious
   * reasons.
   * Also note that if erroneous data is found, it will NOT be removed,
   * but merely flagged as erroneous.
   * @@return A parallel matrix of error correction results
   */
  def errorCorrection(): Seq[ Seq[ Pair[ ReplacementResult, Option[ String ] ] ] ] =
    ( 0 to getRowCount - 1 ).map( row => 
      errorCorrection( row ) )

  /**
   * Executes the replacer at the given position, but only
   * if there is a replacer there.
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return The string from the replacer, or None if there was
   * no replacer
   * @@throws IndexOutOfBoundsException If the given position doesn't
   * exist
   * @@throws ReplaceException If a replacement wasn't possible to determine
   */
  protected def executeReplacer( row: Int,
				 column: Int ): Option[ String ] = {
    if ( isReplacerAt( row, column ) ) {
      Some( getReplacerAt( row, column ).get.replace.data )
    } else None
  }

  /**
   * Sets the value at the given position, but verifies that the value
   * is valid against the cell's replacer
   * @@param item The item to put here
   * @@param row The row to set at
   * @@param column The column to set at
   * @@return A replacement result describing what happened, along with
   * a possible description message of why it happened
d317 1
a317 5
  override def tryValueAt( item: Object,
			   row: Int,
			   column: Int ) = {
    // note that because of the decentralized nature of variables,
    // we have to put the value in and then try to correct it
d319 1
a319 4
    var what: ReplacementResult = null
    var why: Option[ String ] = None

    setValueAt( item, row, column )
d323 6
a328 10
    try {
      val replacement = executeReplacer( row, column )
      what = 
	if ( replacement.isEmpty ||
	     replacement.get == item.toString ) NoError
        else AutoCorrected
    } catch {
      case e: ReplaceException => {
	what = Uncorrectable
	why = Some( e.getMessage )
d330 3
a332 17
      case e: ValueException => {
	what = Uncorrectable
	why = Some( e.getMessage )
      }
      case e: VariableDereferenceException => {
	what = Uncorrectable 
	why = Some( e.getMessage )
      }
    }

    if ( what == Uncorrectable ) {
      setValueAt( oldValue, row, column ) // reset to old value
    }

    ( what,
      why )
  } // tryValueAt
d338 52
a389 1
 * Implementation of ReplacerSpreadsheet that maintains a parallel matrix of replacers.
d391 1
d396 78
a473 26
class DefaultReplacerSpreadsheet( name: String )
extends ParallelSpreadsheet[ Replacer ]( name ) with ReplacerSpreadsheet {
  import java.util.Vector

  /**
   * Sets that a specific replacer is supposed to cover a given cell.
   * If a replacer is already there, then this overwrites it
   * @@param row The row for the replacer
   * @@param column The column for the replacer
   * @@param replacer The replacer to put there
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  override def setReplacerAt( row: Int, column: Int, replacer: Replacer ) =
    setDataAt( row, column, replacer )

  /**
   * Gets the replacer for a specific cell
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return The replacer at this position, or None if there was no
   * replacer here
   * @@throws IndexOutOfBoundsException if the given position doesn't exist
   */ 
  override def getReplacerAt( row: Int, column: Int ) =
    getDataAt( row, column )
}
@


1.2
log
@Refactored spreadsheet hierarchy so that Spreadsheet and
ReplacerSpreadsheet are both traits instead of classes.
@
text
@d5 1
a5 1
 *     $Id: ReplacerSpreadsheet.scala,v 1.1 2010/07/11 05:44:00 kyledewey Exp kyledewey $
d9 4
d69 9
a218 36
}

import scala.collection.mutable.ArrayBuffer

/**
 * Implementation of ReplacerSpreadsheet that maintains a parallel matrix of replacers.
 * @@param name The name of the spreasheet
 * @@throws SpreadsheetNameException if the name of the spreadshet is
 * invalid
 * @@author Kyle Dewey
 */
class DefaultReplacerSpreadsheet( name: String )
extends ParallelSpreadsheet[ Replacer ]( name ) with ReplacerSpreadsheet {
  import java.util.Vector

  /**
   * Sets that a specific replacer is supposed to cover a given cell.
   * If a replacer is already there, then this overwrites it
   * @@param row The row for the replacer
   * @@param column The column for the replacer
   * @@param replacer The replacer to put there
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  override def setReplacerAt( row: Int, column: Int, replacer: Replacer ) =
    setDataAt( row, column, replacer )

  /**
   * Gets the replacer for a specific cell
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return The replacer at this position, or None if there was no
   * replacer here
   * @@throws IndexOutOfBoundsException if the given position doesn't exist
   */ 
  override def getReplacerAt( row: Int, column: Int ) =
    getDataAt( row, column )
d289 37
a325 1
  }
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d18 1
d47 1
a47 1
    new ReplacerSpreadsheet( name )
d59 2
a60 2
  def apply( sheet: Spreadsheet ) = {
    val retval = new ReplacerSpreadsheet( sheet.name )
a66 2
import scala.collection.mutable.ArrayBuffer   

d68 2
a69 6
 * Represents a spreadsheet with replacers in it.  A single cell can
 * have at most one replacer associated with it.
 * @@param name The name of the spreasheet
 * @@param replacers a parallel matrix of replacers
 * @@throws SpreadsheetNameException if the name of the spreadshet is
 * invalid
d72 1
a72 5
class ReplacerSpreadsheet( name: String,
			   protected val replacers: ArrayBuffer[ ArrayBuffer[ Option[ Replacer ] ] ] ) 
extends Spreadsheet( name ) {
  import java.util.Vector

d74 9
a82 5
   * Creates a new replacer spreadsheet, with the given name.
   * The matrix of replacers is initialized to be empty
   * @@param name The name of the spreadsheet
   * @@throws SpreadsheetNameException if the name of the spreadshet is
   * invalid
d84 4
a87 2
  def this( name: String ) =
    this( name, new ArrayBuffer() )
d89 6
d96 6
a101 19
   * Adjusts the replacers matrix so that it has the same number
   * of rows as the spreadsheet.
   */
  def adjustReplacersRows() {
    val numToAdd = getRowCount - replacers.length
    if ( numToAdd > 0 ) {
      ( 0 to numToAdd - 1 ).foreach( current => {
	val currentRow = new ArrayBuffer[ Option[ Replacer ] ]()
	currentRow ++= ( 0 to getColumnCount - 1 ).map( x => None )
	replacers += currentRow
      } )
    } else if ( numToAdd < 0 ) {
      replacers.reduceToSize( getRowCount )
    }
  }

  /**
   * Adjusts the replacers matrix so it has the same number of
   * columns as the spreadsheet
d103 1
a103 10
  def adjustReplacersColumns() {
    replacers.foreach( row => {
      val numToAdd = getColumnCount - row.length
      if ( numToAdd > 0 ) {
	( 0 to numToAdd - 1 ).foreach( current => row += None )
      } else if ( numToAdd < 0 ) {
	row.reduceToSize( getColumnCount )
      }
    } )
  }
d106 8
a113 7
   * Adjusts the replacers matrix such that it's size is the same
   * as the spreadsheet.
   */
  def adjustReplacers() {
    adjustReplacersColumns()
    adjustReplacersRows()
  }
d116 4
a119 34
   * Adds a column to the end of the model.
   * Overridden in order to keep replacers in line
   * @@param columnName The name of the column
   * @@param columnData The data for the column
   */
  override def addColumn( columnName: Object,
			  columnData: Vector[ _ ] ) {
    super.addColumn( columnName,
		     columnData )
    replacers.elements.foreach( _ += None )
  }
  
  /**
   * Adds a row to an arbitrary position in the model
   * Overridden in order to keep replacers in line
   * @@param rowPos The position at which to insert the row
   * @@param rowData The data to put there
   * @@throws ArrayIndexOutOfBoundsException If the row was invalid
   */
  override def insertRow( rowPos: Int,
			  rowData: Vector[ _ ] ) {
    super.insertRow( rowPos,
		     rowData )
    val newRow = new ArrayBuffer[ Option[ Replacer ] ]()
    ( 0 to getColumnCount - 1 ).foreach( iteration => newRow += None )
    replacers += newRow
  }

  /**
   * Sets that a specific replacer is supposed to cover a given cell.
   * If a replacer is already there, then this overwrites it
   * @@param row The row for the replacer
   * @@param column The column for the replacer
   * @@param replacer The replacer to put there
d122 2
a123 5
  def setReplacerAt( row: Int,
		     column: Int,
		     replacer: Replacer ) {
    replacers( row )( column ) = Some( replacer )
  }
a160 23
   * Gets the replacer for a specific cell
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return The replacer at this position, or None if there was no
   * replacer here
   * @@throws IndexOutOfBoundsException if the given position doesn't exist
   */ 
  def getReplacerAt( row: Int,
		     column: Int ) = 
    replacers( row )( column )

  /**
   * Determines if there is a replacer at the given position
   * @@param row The row of the replacer
   * @@param column The column of the replacer
   * @@return true If there is a replacer here, else false
   * @@throws IndexOutOfBoundsException If the given position doesn't exist
   */
  def isReplacerAt( row: Int,
		    column: Int ) =
    getReplacerAt( row, column ).isDefined

  /**
d170 1
a170 3
  def setReplacerAtIfEmpty( row: Int,
			    column: Int,
			    replacer: Replacer ) = {
d178 66
d264 1
a266 1
   * @@param item The item to put here
d272 3
a274 3
  def tryValueAt( item: Object,
		  row: Int,
		  column: Int ) = {
a312 41

  /**
   * Performs error correction on the given row.
   * Note that uncorrectable errors will remain in the spreadsheet, though
   * autocorrected data will replace old data.
   * @@param row The row to perform error correction on
   * @@return The error correction results of the given row
   */
  def errorCorrection( row: Int ) =
    // MAJOR GOTCHA
    // without the .force, the error correction rules
    // would be evaulated every time calling code attempts to see the
    // result.  That is, every time the result is used, the error
    // correction language is executed again!
    ( 0 to getColumnCount - 1 ).map( column =>
      tryValueAt( getValueAt( row, column ),
		  row,
		  column ) ).force
  
  /**
   * Performs error correction on the entire spreadsheet.
   * Note that this is very computationally expensive, for obvious
   * reasons.
   * Also note that if erroneous data is found, it will NOT be removed,
   * but merely flagged as erroneous.
   * @@return A parallel matrix of error correction results
   */
  def errorCorrection(): Seq[ Seq[ Pair[ ReplacementResult, Option[ String ] ] ] ] = 
    ( 0 to getRowCount - 1 ).map( row => 
      errorCorrection( row ) )

  /**
   * Merely updates the data and adjusts the replacers as neccessary
   * @@param data The data to put into this sheet
   * @@param identifiers The new column identifiers
   */
  override def setDataVector( data: Vector[ _ ],
			      identifiers: Vector[ _ ] ) {
    super.setDataVector( data, identifiers )
    adjustReplacers()
  }
@
