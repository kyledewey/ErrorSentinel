head	1.12;
access;
symbols;
locks
	kyledewey:1.12; strict;
comment	@# @;


1.12
date	2011.06.21.17.01.04;	author kyledewey;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.08.04.26.15;	author kyledewey;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.07.08.17.44;	author kyledewey;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.25.20.14.58;	author kyledewey;	state Exp;
branches;
next	1.8;

1.8
date	2010.06.28.18.43.38;	author kyledewey;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.26.04.05.40;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.20.23.29.25;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.20.17.29.42;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2010.06.18.19.36.58;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.18.03.09.10;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.16.01.00.24;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.15.17.56.01;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains helper code for replacers along with
built in replacers.
@


1.12
log
@Overrode Debugger's sentStringValue() so that the value
of matchers can now be seen without wrapping.
@
text
@/*
 * Replacer.scala
 *
 * Version:
 *     $Id: Replacer.scala,v 1.11 2011/06/08 04:26:15 kyledewey Exp $
 *
 * Revisions:
 *      $Log: Replacer.scala,v $
 *      Revision 1.11  2011/06/08 04:26:15  kyledewey
 *      Now conforms to the new Param interface.
 *
 *      Revision 1.10  2011/06/07 08:17:44  kyledewey
 *      Added replacer types to nonpolymorphic routines.
 *
 *      Revision 1.9  2011/05/25 20:14:58  kyledewey
 *      Made it so the class name is also taken as a parameter.
 *
 *      Revision 1.8  2010/06/28 18:43:38  kyledewey
 *      Made it so concat can take an optional start, delimiter, and end
 *      string.
 *
 *      Revision 1.7  2010/06/26 04:05:40  kyledewey
 *      Added helper functions that are common to multiple replacers.
 *
 *      Revision 1.6  2010/06/20 23:29:25  kyledewey
 *      Slightly modified replacers to reflect the new
 *      return type of Data for replace().
 *
 *      Revision 1.5  2010/06/20 17:29:42  kyledewey
 *      Moved factory code to sentinel.model.Factory.scala.
 *
 *      Revision 1.4  2010/06/18 19:36:58  kyledewey
 *      Made factories take a name and description.
 *
 *      Revision 1.3  2010/06/18 03:09:10  kyledewey
 *      Made it so factory calls internalInstantiate().
 *
 *      Revision 1.2  2010/06/16 01:00:24  kyledewey
 *      Fixed typo in name of ParameterizedInstantiationException.
 *
 *      Revision 1.1  2010/06/15 17:56:01  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.model.replacer

import sentinel.model._
import sentinel.model.matcher.StringHelpers._
import sentinel.model.Replacer._
import sentinel.model.InstanceFactory._

/**
 * Contains helper methods common to different replacers.
 * @@author Kyle Dewey
 */
object Replacer {
  def max[ T <: Comparable[ T ] ]( first: T, second: T ): T =
    if ( first.compareTo( second ) > 0 ) first else second

  def min[ T <: Comparable[ T ] ]( first: T, second: T ): T =
    if ( first.compareTo( second ) < 0 ) first else second
	 
  /**
   * Gets the maximum value in the given items.
   * @@param items The items to get the max of
   * @@return The maximum value in the items
   * @@throws ValueException If we could not get the value of an element
   * @@pre items contains at least one element
   */
  def max[ T <: Comparable[ T ] ]( items: Seq[ T ] ): T = 
    items.reduceLeft( max( _, _ ) )

  /**
   * Gets the miniumum value in the given items.
   * @@param items The items to get the minimum of
   * @@return The minimum value in the items
   * @@throws ValueException If we could not get the value of an element
   * @@pre items contains at least one element
   */
  def min[ T <: Comparable[ T ] ]( items: Seq[ T ] ): T =
    items.reduceLeft( min( _, _ ) )
}

/**
 * Replacer that will concatenate its arguments together,
 * and return that as the replacement.
 * If no arguments are specified, then it will return null string
 * @@param className The name of the class
 * @@param params Params to the replacer
 * <ul><li>"data": one or more of any data</li>
 * <li>"start": Any data to put at the start before concatenation.  Defaults
 * to a null string.</li>
 * <li>"delimiter": Any data to put between each item.  Defaults to a null
 * string.</li>
 * <li>"end": Any data to put at the end of concatentation.  Defaults to
 * a null string.</li></ul>
 * @@author Kyle Dewey
 */
class Concat( val className: String,
	      val params: Seq[ NamedParam ] ) extends Replacer {
  private val input = asArray( "data", params )
  private val start = 
    opParam( "start", params ).getOrElse( Constant( "" ) )
  private val delim = 
    opParam( "delimiter", params ).getOrElse( Constant( "" ) )
  private val end = 
    opParam( "end", params ).getOrElse( Constant( "" ) )

  /**
   * Concatenates all given strings
   * @@return The concatenation, or null string if there were none
   */
  override def replace() =
    toStrings( input ).mkString( start.sentStringValue,
				 delim.sentStringValue,
				 end.sentStringValue )
}

/**
 * <p>Replacer that acts as a simple conditional <b>expression</b>.
 * Not to be confused with an if statement.<p>
 * 
 * <p>In more detail, this acts as a functional if expression, not an
 * imperative if statement.  The imperative if statement, such as:
 * <code>int x = 0; if( true ) { x++; }</code> does not return anything,
 * and its function is based purely on side effects.  On the other hand,
 * the functional if statement, like: <code>int x = 0; if ( true ) x + 1 else x
 * </code>returns a value under all conditions, and does not rely upon
 * side effects.</p>
 *
 * <p>The difference may seem trivial, but it is a marked difference between
 * functional and imperative languages.  The error correction langauge
 * is object oriented and functional.  Note that the else clause is required,
 * as it is in many ML derived languages.  The reason for this isn't to be
 * "pure", but rather to force the user to understand exactly the consequences
 * of using the power but dangerous if expression.</p>
 *
 * <p>To make things much simpler, this if expression is roughly
 * equivalent to ?: ternary operator found in many imperative, C
 * derived languages.  In a C based languge, this would be like
 * <code>( true ) ? 1 : 0</code>, where in this language it would be
 * like <code>if ( true ) 1 else 0</code></p>
 *
 * @@param className The name of the class
 * @@param params to the replacer<ul>
 *         <li>"if": A matcher that will determine whether or not the condition
 *         has occurred</li>
 *        <li>"then": Data that will be returned if the condition is true</li>
 *        <li>"else": Data that will be returned if the condition is false</li>
 *        </ul>
 * @@author Kyle Dewey
 */
class Conditional( val className: String,
		   val params: Seq[ NamedParam ] ) extends Replacer {
  private val ifMatches = param( "if", params ).matcherValue
  private val thenDo = param( "then", params )
  private val elseDo = param( "else", params )

  /**
   * If the condition is true, then "then" will be executed.  Otherwise,
   * "else" will be executed.
   * @@return The replacement, according to the above description
   */
  override def replace() =
    if ( ifMatches.matches ) thenDo else elseDo
}

/**
 * Merely throws a replacer exception.
 * @@param className The name of the class
 * @@param params Params to the replacer
 * <ul><li>"message": any data to show what happened</li></ul>
 * @@author Kyle Dewey
 */
class ThrowReplaceException( val className: String,
			     val params: Seq[ NamedParam ] ) extends Replacer {
  private val message = param( "message", params )

  /**
   * Doesn't actually ever return.
   * Merely throws an exception with whatever message was given.
   * @@return nothing
   * @@throws ReplaceException Under all cases
   */
  override def replace() =
    throw new ReplaceException( message.sentStringValue )
}
  
/**
 * Simple debugging utility.
 * Merely passes its parameter along, if it got one.  Otherwise it returns
 * a null string.
 * @@param className The name of the class
 * @@param params Parameters to the replacer<ul>
 * <li>"input": Any data.  Optional.</li></ul>
 * @@author Kyle Dewey 
 */
class Debugger( val className: String,
	        val params: Seq[ NamedParam ] ) extends Replacer {
  private val input = opParam( "input", params )

  /**
   * If we have an input, it returns the input as-is.  Otherwise it
   * returns a null string
   * @@return The input as-is, or a null string
   */
  override def replace() =
    if ( input.isDefined ) input.get else ""

  /**
   * Uses <code>printableValueUnsafe</code> instead of sentStringValue.
   * This is so input matchers can have their values shown properly.
   * @@return A string representation of the given parameter
   */
  override def sentStringValue() =
    replace.printableValueUnsafe
}
@


1.11
log
@Now conforms to the new Param interface.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.10 2011/06/07 08:17:44 kyledewey Exp kyledewey $
d9 3
d211 8
@


1.10
log
@Added replacer types to nonpolymorphic routines.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.9 2011/05/25 20:14:58 kyledewey Exp $
d9 3
d47 1
d56 6
d69 2
a70 6
  def max[ T ]( items: Seq[ Value[ T ] ] ) = {
    var max = items( 0 )
    items.foreach( item =>
      if ( item > max ) max = item )
    max
  }
d79 2
a80 6
  def min[ T ]( items: Seq[ Value[ T ] ] ) = {
    var min = items( 0 )
    items.foreach( item =>
      if ( item < min ) min = item )
    min
  }
d99 2
a100 2
	      val params: Seq[ NamedParam ] ) extends SentStringReplacer {
  private val input = asArray[ Data ]( "data", params )
d102 1
a102 1
    opParam[ Data ]( "start", params ).getOrElse( Constant( "" ) )
d104 1
a104 1
    opParam[ Data ]( "delimiter", params ).getOrElse( Constant( "" ) )
d106 1
a106 1
    opParam[ Data ]( "end", params ).getOrElse( Constant( "" ) )
d113 3
a115 3
    input.map( _.data ).mkString( start.data,
				  delim.data,
				  end.data )
d154 3
a156 3
  private val ifMatches = param[ Matcher ]( "if", params )
  private val thenDo = param[ Data ]( "then", params )
  private val elseDo = param[ Data ]( "else", params )
d176 1
a176 1
  private val message = param[ Data ]( "message", params )
d185 1
a185 1
    throw new ReplaceException( message.data )
d199 1
a199 1
  private val input = opParam[ Data ]( "input", params )
@


1.9
log
@Made it so the class name is also taken as a parameter.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.8 2010/06/28 18:43:38 kyledewey Exp $
d9 3
d97 1
a97 1
	      val params: Seq[ NamedParam ] ) extends Replacer {
@


1.8
log
@Made it so concat can take an optional start, delimiter, and end
string.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.7 2010/06/26 04:05:40 kyledewey Exp $
d9 4
d82 1
d93 2
a94 1
class Concat( params: Seq[ NamedParam ] ) extends Replacer {
d138 1
d147 2
a148 1
class Conditional( params: Seq[ NamedParam ] ) extends Replacer {
d164 1
d169 2
a170 1
class ThrowReplaceException( params: Seq[ NamedParam ] ) extends Replacer {
d183 21
@


1.7
log
@Added helper functions that are common to multiple replacers.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.6 2010/06/20 23:29:25 kyledewey Exp kyledewey $
d9 3
d79 7
a85 1
 *        <ul><li>"input": zero or more of any data</li></ul>
d89 7
a95 1
  private val input = asArray[ Data ]( "input", params )
d102 3
a104 1
    input.map( _.data ).foldLeft( "" )( _ + _ ) 
@


1.6
log
@Slightly modified replacers to reflect the new
return type of Data for replace().
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.5 2010/06/20 17:29:42 kyledewey Exp kyledewey $
d9 4
d34 1
a34 1
import sentinel.model.Replacer._ // for string2Data
d37 33
a69 1
// BEGIN BUILT IN REPLACERS
d76 1
a76 1
 *        -"input": zero or more of any data
d115 6
a120 5
 * @@param params to the replacer
 *        -"if": A matcher that will determine whether or not the condition
 *         has occurred
 *        -"then": Data that will be returned if the condition is true
 *        -"else": Data that will be returned if the condition is false
d137 18
@


1.5
log
@Moved factory code to sentinel.model.Factory.scala.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.4 2010/06/18 19:36:58 kyledewey Exp kyledewey $
d9 3
d30 1
d97 1
a97 1
    if ( ifMatches.matches ) thenDo.data else elseDo.data
@


1.4
log
@Made factories take a name and description.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.3 2010/06/18 03:09:10 kyledewey Exp kyledewey $
d9 3
d27 1
a27 104
import sentinel.model.parser._
import sentinel.model.ParameterizedObjectFactory._

/**
 * Exception thrown if the underlying type isn't a replacer.
 * @@param message Message for the exception
 * @@author Kyle Dewey
 */
case class NonReplacerException( message: String ) 
     extends Exception( message ) {
  /**
   * Creates a new exception with no message
   */
  def this() =
    this( null )
}

/**
 * Contains functions and values common to
 * replacer factories.
 * @@author Kyle Dewey
 */
object ReplacerFactory {
  // begin constants
  val BAD_CLASS = "Replacer factory attempted to instantiate non-replacer class"
  // end constants

  /**
   * Casts something to a replacer.  If the cast was unsuccessful,
   * it will throw an exception.
   * @@param item The item to cast to a replacer
   * @@return The item as a replacer
   * @@throws ParameterizedInstantiationException If the item is not a replacer
   */
  def toReplacer( item: Any ): Replacer = {
    try {
      item.asInstanceOf[ Replacer ]
    } catch {
      case e: ClassCastException =>
	throw new ParameterizedInstantiationException( BAD_CLASS, e )
    }
  }
}

/**
 * Definition for a factory that can create a replacer.
 * @@param name The name of the factory
 * @@param desc a description of the factory
 * @@param neededParams What params are needed to instantiate the replacer
 *
 * @@author Kyle Dewey
 */
abstract class ReplacerFactory( name: String,
			        desc: String,
			        neededParams: Map[ String, ParamInfo ] )
extends ParameterizedObjectFactory[ Replacer ]( name,
					        desc,
					        neededParams ) {}

/**
 * Definition for a factory that creates a replacer based upon an
 * existing class in the JVM.
 * @@param name The name of the factory
 * @@param desc A description of the factory
 * @@param neededParams The parameters to the underlying replacer
 * @@param JVMClassName The name of the class that backs instances created
 *        by the factory
 * @@author Kyle Dewey
 */
class ReflectionReplacerFactory( name: String,
				 desc: String,
				 neededParams: Map[ String, ParamInfo ],
			         val JVMClassName: String )
extends ReplacerFactory( name,
			 desc,
			 neededParams ) {
  import ReplacerFactory._

  private val reflector = new ReflectionFactory[ Replacer ]( name,
							     desc,
							     neededParams,
							     JVMClassName )

  /**
   * Creates a new instance of the underlying replacer using
   * reflection.
   * @@param params Params to construct the underlying replacer with
   * @@return A new replacer instantiated with the given params
   * @@throws ParameterizedInstantiationException If the params were ok
   *         but the underlying replacer could not be instantiated
   */
  override def internalInstantiate( params: Seq[ NamedParam ] ): Replacer = 
    // safe to call internal, as it shares the same parameters as
    // we do.  For us to get here, our params have already been
    // verified.
    toReplacer( reflector.internalInstantiate( params ) )
}

/**
 * Organizes replacer factories.
 * @@author Kyle Dewey
 */
object ReplacerFactoryManager
extends FactoryManager[ Replacer, ParameterizedObjectFactory[ Replacer ] ]() {}
@


1.3
log
@Made it so factory calls internalInstantiate().
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.2 2010/06/16 01:00:24 kyledewey Exp kyledewey $
d9 3
d70 2
a71 1
 *
d76 6
a81 2
abstract class ReplacerFactory( neededParams: Map[ String, ParamInfo ] )
extends ParameterizedObjectFactory[ Replacer ]( neededParams ) {}
d86 2
a87 1
 * @@param className The name of the class to create
d89 2
d93 7
a99 3
class ReflectionReplacerFactory( val className: String,
			        neededParams: Map[ String, ParamInfo ] )
extends ReplacerFactory( neededParams ) {
d102 4
a105 2
  private val reflector = new ReflectionFactory[ Replacer ]( className,
							     neededParams )
@


1.2
log
@Fixed typo in name of ParameterizedInstantiationException.
@
text
@d5 1
a5 1
 *     $Id: Replacer.scala,v 1.1 2010/06/15 17:56:01 kyledewey Exp kyledewey $
d9 3
d99 4
a102 1
    toReplacer( reflector.instantiate( params ) )
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d50 1
a50 1
   * @@throws ParameterizedInstantationException If the item is not a replacer
d57 1
a57 1
	throw new ParameterizedInstantationException( BAD_CLASS, e )
d92 1
a92 1
   * @@throws ParameterizedInstantationException If the params were ok
@
