head	1.8;
access;
symbols;
locks
	kyledewey:1.8; strict;
comment	@# @;


1.8
date	2011.06.18.03.31.09;	author kyledewey;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.08.04.29.49;	author kyledewey;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.01.04.02.34;	author kyledewey;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.29.15.18.34;	author kyledewey;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.27.01.34.03;	author kyledewey;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.25.21.54.04;	author kyledewey;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.25.20.16.07;	author kyledewey;	state Exp;
branches;
next	1.1;

1.1
date	2010.07.11.05.54.17;	author kyledewey;	state Exp;
branches;
next	;


desc
@Contains container classes for representing a
single spreadsheet project.
@


1.8
log
@Set to not use optimizations.
More testing needs to be done before this can be set otherwise.
@
text
@/*
 * Parser.scala
 *
 * Version:
 *     $Id: Parser.scala,v 1.7 2011/06/08 04:29:49 kyledewey Exp $
 *
 * Revisions:
 *      $Log: Parser.scala,v $
 *      Revision 1.7  2011/06/08 04:29:49  kyledewey
 *      Now uses toString instead of getMessage for exceptions.
 *
 *      Revision 1.6  2011/06/01 04:02:34  kyledewey
 *      Spreadsheet registration is now parameterized.
 *
 *      Revision 1.5  2011/05/29 15:18:34  kyledewey
 *      Can now do piecewise loading.
 *
 *      Revision 1.4  2011/05/27 01:34:03  kyledewey
 *      Refactored so that the routine used to transform
 *      vanilla spreadsheets into a custom version is passed
 *      as a parameter instead of being hardcoded.
 *
 *      Revision 1.3  2011/05/25 21:54:04  kyledewey
 *      Added support for values instead of just variables.
 *
 *      Revision 1.2  2011/05/25 20:16:07  kyledewey
 *      Refactored so spreadsheet variables can be passed directly
 *      in the XML file.  Helps to decouple code from the sheet.
 *
 *      Revision 1.1  2010/07/11 05:54:17  kyledewey
 *      Initial revision
 *
 *
 */

package sentinel.project

import java.io._
import sentinel.model._

/**
 * Exception thrown when there was an error on read in a project's definition.
 * @@param message An informative message to show the user
 * @@author Kyle Dewey
 */
case class ProjectParseException( message: String )
     extends IOException( message ) {}

/**
 * Interface that describes something that can read in a project
 * @@author Kyle Dewey
 */
trait ProjectParser {
  /**
   * Parses in a project in from the given file
   * @@param file The file to read from
   * @@param spreadsheetFactory Something that can convert spreadsheets
   * to a given desired format.  Takes a spreadsheet, the project being made,
   * and whether or not to register the spreadsheet as a parameter
   * @@param register Whether or not to register the created spreadsheets
   * @@throws ProjectParseException If a format-level reading error occurred
   * @@throws FileNotFoundException If the file could not be opened
   * @@throws IOException If an error occurred on read
   */
  def parseProject[ T <: Spreadsheet ]( file: File, 
				        spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T,
				        register: Boolean ): Project[ T ]

  /**
   * Parses in a project in from the given file
   * @@param fileName The name of the file to read from
   * @@param spreadsheetFactory Something that can convert spreadsheets
   * to a given desired format.  Takes a spreadsheet, the project being made,
   * and whether or not to register the spreadsheet as a parameter.
   * @@param register Whether or not to register the created spreadsheets
   * @@throws ProjectParseException If a format-level reading error occurred
   * @@throws FileNotFoundException If the file could not be opened
   * @@throws IOException If an error occurred on read
   */
  def parseProject[ T <: Spreadsheet ]( fileName: String, 
				        spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T,
				        register: Boolean ): Project[ T ] = 
    parseProject( new File( fileName ), 
		  spreadsheetFactory,
	          register )
}

/**
 * Something that can read in a project in XML format.
 * @@author Kyle Dewey
 */
object ParseXML extends ProjectParser {
  import scala.xml._

  def getNodes( base: Node, tag: String ) =
    XMLHelpers.getNodes( base, tag, ProjectParseException( _ ) )

  def getText( base: Node, tag: String ) =
    XMLHelpers.getText( base, tag, ProjectParseException( _ ) )

  /**
   * Given the text of a row, it will return the corresponding row
   * @@param text The text of the row
   * @@return The row, or None if it's a reference to the current row
   * @@throws ProjectParseException If an actual row was passed, but it
   * wasn't an integer
   */
  def textToRow( text: String ): Option[ Int ] = {
    import sentinel.model.parser._
    try {
      ClassParser.textToRow( text )
    } catch {
      case e: ClassParseException =>
	throw new ProjectParseException( e.getMessage )
    }
  }

  /**
   * Given the text of a column, it will return the corresponding
   * column.
   * @@param text The text of the column
   * @@return The column, or None if it's a reference to the current column
   * @@throws ProjectParseException If an actual column was passed, but it
   * wasn't an integer
   */
  def textToColumn( text: String ): Option[ Int ] = {
    import sentinel.model.parser._
    try {
      ClassParser.textToColumn( text )
    } catch {
      case e: ClassParseException =>
	throw new ProjectParseException( e.getMessage )
    }
  }

  /**
   * Parses in a cell range.
   * @@param range The node containing cell range information
   * @@return A new cell range encapsulating the information in the cell
   * range
   * @@throws ProjectParseException If required information is missing
   */
  def parseCellRangeNode( range: Node ) = {
    import sentinel.model.parser._
    new CellRange( ClassParser.textToSpreadsheet( getText( range, "Sheet" ) ),
		   textToRow( getText( range, "Row" ) ),
		   textToColumn( getText( range, "Column" ) ) )
  }

  /**
   * Parses in a value node
   * @@param valueNode The value node
   * @@return A named parameter holding the value information
   * @@throws ProjectParseException If required information is missing or
   * exising information is invalid
   */
  def parseValueNode( valueNode: Node ) = {
    val ( name,
	  theType ) = getNameAndType( valueNode )
    val value = getText( valueNode, "Contents" )
    val asParam = Constant( theType, value )
    if ( asParam.isEmpty ) {
      throw new ProjectParseException( "Value \"" + value + "\" is " +
				       "incompatible with type " +
				       ParamType.paramToString( theType ) )
    } else {
      new NamedParam( name, asParam.get )
    }
  }
    
  /**
   * Parses in a values node
   * @@param values The values node
   * @@return Named parameters holding the values
   * @@throws ProjectParseException If required information is missing or
   * exising information is invalid
   */
  def parseValuesNode( values: Node ) =
    ( values \ "Value" ).map( parseValueNode( _ ) )

  /**
   * Gets the name and type of a variable or value node
   * @@param node The variable or value node
   * @@return The name and the type in a pair
   * @@throws ProjectParseException If required information is missing or
   * exising information is invalid
   */
  def getNameAndType( node: Node ) = {
    var typeName = ""

    try {
      typeName = getText( node, "Type" )
      Pair( getText( node, "Name" ),
	    ParamType.stringToParam( typeName ) )
    } catch {
      case e: NoSuchElementException => 
	throw new ProjectParseException( "Unknown variable type: " + typeName )
    }
  }

  /**
   * Parses in a variable node
   * @@param variable The variable node
   * @@return A new named parameter holding the variable
   * @@throws ProjectParseException If required information is missing or
   * exising information is invalid
   */
  def parseVariableNode( variable: Node ) = {
    import java.util.NoSuchElementException
    var theType = ParamType.StringType
    try {
      val pair = getNameAndType( variable )
      val name = pair._1
      theType = pair._2
      val range = parseCellRangeBelow( variable )
      new NamedParam( name, 
		      new SpreadsheetVariable( range ) )
    } catch {
      case e: UnknownSpreadsheetVariableType =>
	throw new ProjectParseException( "Unknown spreadsheet variable type: " +
					 ParamType.toString( theType ) )
    }
  }

  /**
   * Parses in a variables node
   * @@param variables The variables node
   * @@retrun a sequence of named parameters correlating to the variables
   * @@throws ProjectParseException If required information is missing or
   * exising information is invalid
   */
  def parseVariablesNode( variables: Node ) =
    ( variables \ "Variable" ).map( parseVariableNode( _ ) )

  /**
   * Parses in an instance factory node.
   * @@param instanceNode The node containing instance information
   * @@return The instance associated with the given node
   * @@throws ProjectParseException If required information is missing,
   * or there is no such factory with this name.  Also if we could not
   * instantiate it.
   * @@pre Languages that are associated with this project parsed in in full
   */
  def parseInstanceNode( instanceNode: Node ) = {
    val className = getText( instanceNode, "ClassName" )
    try {
      val factory = FactoryManager.getFactory( instanceNode.label,
					       className )
      val variables =
	parseVariablesNode( getNodes( instanceNode, "Variables" ).first )
      val values =
	parseValuesNode( getNodes( instanceNode, "Values" ).first )
      
      factory.get.instantiate( variables ++ values, false )
    } catch {
      case e: NoSuchElementException =>
	throw new ProjectParseException( "No such factory with name: " + className )
      case e: UnknownFactoryTypeException => 
	throw new ProjectParseException( e.toString )
      case e: ParameterNameException =>
	throw new ProjectParseException( e.toString )
      case e: ParameterRequirementException =>
	throw new ProjectParseException( e.toString )
      case e: ParameterTypeException =>
	throw new ProjectParseException( e.toString )
      case e: ParameterArrayException =>
	throw new ProjectParseException( e.toString )
      case e: ParameterizedInstantiationException => 
	throw new ProjectParseException( e.toString )
    }
  } // parseInstanceNode
  
  /**
   * Parses in the first instance underneath the given node
   * @@param node The base node
   * @@param instanceType Either "Matcher" or "Replacer"
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseInstanceBelow( node: Node, instanceType: String ) =
    parseInstanceNode( getNodes( node, instanceType ).first )

  /**
   * Parses in the first cell range node beneath the given node
   * @@param node The base node
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseCellRangeBelow( node: Node ) =
    parseCellRangeNode( getNodes( node, "CellRange" ).first )

  /**
   * Parses in a "GoodData" node.
   * @@param goodData The good data node
   * @@return A pair holding [ matcher, cellRange ]
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseGoodDataNode( goodData: Node ) =
    Pair( parseInstanceBelow( goodData, "Matcher" ).asInstanceOf[ Matcher ],
	  parseCellRangeBelow( goodData ) )
  
  /**
   * Parses in a "GoodDatas" node.
   * @@param goodDatas The good datas node holding good data information
   * @@return a sequence of [ goodData, range ] pairs
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseGoodDatasNode( goodDatas: Node ) =
    ( goodDatas \ "GoodData" ).map( parseGoodDataNode( _ ) )

  /**
   * Parses in an "ErrorCorrection" node
   * @@param errorCorrection the error correction node
   * @@return A pair holding the matcher/replacer pair, along with
   * the cell range that it applies to
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseErrorCorrectionNode( errorCorrection: Node ) = {
    val matcher = parseInstanceBelow( errorCorrection, "Matcher" )
    val replacer = parseInstanceBelow( errorCorrection, "Replacer" )
    val range = parseCellRangeBelow( errorCorrection )
    Pair( Pair( matcher.asInstanceOf[ Matcher ], 
	        replacer.asInstanceOf[ Replacer ] ), 
	  range )
  }
  
  /**
   * Parses in an "ErrorCorrections" node
   * @@param errorCorrections The error corrections node
   * @@return A seq holding all the error corrections
   * @@throws ProjectParseException If required information is missing or
   * invalid
   */
  def parseErrorCorrectionsNode( errorCorrections: Node ) =
    ( errorCorrections \ "ErrorCorrection" ).map( parseErrorCorrectionNode( _ ) )

  /**
   * Parses in the associations node
   * @@param associations The node containing associations information
   * @@return A new associations encapsulating the information in the
   * association
   * @@throws ProjectParseException If required information is missing
   * or invalid
   */
  def parseAssociationsNode( associations: Node ) = {
    val goodData =
      parseGoodDatasNode( getNodes( associations, "GoodDatas" ).first )
    val errorCorrections =
      parseErrorCorrectionsNode( getNodes( associations, "ErrorCorrections" ).first )
    new Associations( goodData, errorCorrections )
  }
  
  /**
   * Parses in a sheet node.
   * @@param sheet The sheet node
   * @@return A new sheet, encapsulating the information in the node
   * @@throws ProjectParseException If some required information was missing
   */
  def parseSheetNode( sheet: Node ) =
    new Sheet( getText( sheet, "Name" ),
	       getText( sheet, "File" ),
	       getText( sheet, "Type" ) )
  
  /**
   * Parses in a sheets node
   * @@param sheets The sheets to parse in
   * @@return A new sequence of sheets, encapsulating the information
   * in the node
   * @@throws ProjectParseException If some required information was missing
   */
  def parseSheetsNode( sheets: Node ): Seq[ Sheet ] =
    ( sheets \ "Sheet" ).map( parseSheetNode( _ ) )
  
  /**
   * Parses in a definition node.
   * @@param definition The definition node to parse in
   * @@return A new language definition encapsulating the information
   * @@throws ProjectParseException If some required information was missing
   * @@throws UnknownLanguageTypeException If the given file type isn't known
   * @@throws ClassParseException If an error occurred while parsing
   * @@throws IOException If an error occurred on reading
   */
  def parseDefinitionNode( definition: Node ) = {
    val file = getText( definition, "File" )
    val theType = getText( definition, "Type" )
    new Language( file, theType )
  }
  
  /**
   * Parses in a definitions node
   * @@param definitions The definitions node to parse in
   * @@return A new sequence of language definitions encapsulating the
   * information
   * @@throws ProjectParseException If some required information was missing
   * @@throws UnknownLanguageTypeException If the given file type isn't known
   * @@throws ClassParseException If an error occurred while parsing
   * @@throws IOException If an error occurred on reading
   */
  def parseDefinitionsNode( definitions: Node ): Seq[ Language ] =
    ( definitions \ "Definition" ).map( parseDefinitionNode( _ ) )
  
  /**
   * Parses in a project node.
   * @@param project The project node
   * @@param spreadsheetFactory Something that can convert spreadsheets
   * to a given desired format.  Takes a spreadsheet and whether or not to
   * register the spreadsheet as a parameter
   * @@param register Whether or not to register the spreadsheets
   * @@return A project
   * @@throws ProjectParseException If some required information was missing
   * @@throws UnknownLanguageTypeException If the given file type isn't known
   * @@throws ClassParseException If an error occurred while parsing
   * @@throws ParameterizedInstantiationException If we could not
   * instantiate a replacer
   * @@throws IOException If an error occurred on reading
   */
  def parseProjectNode[ T <: Spreadsheet ]( project: Node, 
					    spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T,
					    register: Boolean ) = {
    val sheets = parseSheetsNode( getNodes( project, "Sheets" ).first )
    val definitions = 
      parseDefinitionsNode( getNodes( project, "Definitions" ).first )
    LanguageReader.readLanguages( definitions )
    val associations =
      parseAssociationsNode( getNodes( project, "Associations" ).first )
    new Project[ T ]( Map() ++ sheets.map( sheet => sheet.name -> sheet ),
		      definitions,
	              associations,
		      spreadsheetFactory,
		      register )
  }

  /**
   * Parses in a project in from the given file
   * @@param file The file to read from
   * @@param spreadsheetFactory Something that can convert spreadsheets
   * to a given desired format.  Takes a spreadsheet and whether or not to
   * register the spreadsheet as a parameter
   * @@param register Whether or not to register the created spreadsheet
   * @@throws ProjectParseException If a format-level reading error occurred
   * @@throws FileNotFoundException If the file could not be opened
   * @@throws UnknownLanguageTypeException If the given file type isn't known
   * @@throws ClassParseException If an error occurred while parsing
   * @@throws ParameterizedInstantiationException If we could not
   * instantiate a replacer
   * @@throws IOException If an error occurred on reading
   */
  def parseProject[ T <: Spreadsheet ]( file: File, 
				        spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T,
				        register: Boolean ) = {
    val contents = XML.loadFile( file )
    parseProjectNode( contents, 
		      spreadsheetFactory,
		      register )
  }
}
@


1.7
log
@Now uses toString instead of getMessage for exceptions.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.6 2011/06/01 04:02:34 kyledewey Exp $
d9 3
d254 1
a254 1
      factory.get.instantiate( variables ++ values )
@


1.6
log
@Spreadsheet registration is now parameterized.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.5 2011/05/29 15:18:34 kyledewey Exp $
d9 3
d214 1
a214 1
		      SpreadsheetVariable( theType, range ) )
d256 1
a256 1
	throw new ProjectParseException( e.getMessage )
d258 1
a258 1
	throw new ProjectParseException( e.getMessage )
d260 1
a260 1
	throw new ProjectParseException( e.getMessage )
d262 1
a262 1
	throw new ProjectParseException( e.getMessage )
d264 3
a266 3
	throw new ProjectParseException( e.getMessage )
      case e: ParameterizedInstantiationException =>
	throw new ProjectParseException( e.getMessage )
@


1.5
log
@Can now do piecewise loading.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.4 2011/05/27 01:34:03 kyledewey Exp $
d9 3
d54 1
d59 3
a61 1
  def parseProject[ T <: Spreadsheet ]( file: File, spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T ): Project[ T ]
d69 1
d74 6
a79 2
  def parseProject[ T <: Spreadsheet ]( fileName: String, spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T ): Project[ T ] = 
    parseProject( new File( fileName ), spreadsheetFactory )
d89 2
a90 15
  /**
   * Parses in text from a node.
   * @@param node The root node to get text from
   * @@param tag The tag under which to look for text
   * @@return The text underneath the nodes
   * @@throws ProjectParseException If there was no text
   */
  def getText( node: Node, tag: String ): String = {
    try {
      sentinel.model.parser.xml.XMLParser.getText( node, tag )
    } catch {
      case e: sentinel.model.parser.ClassParseException =>
	throw new ProjectParseException( e.getMessage )
    }
  }
d92 2
a93 16
  /**
   * Parses in a node, making sure that we had something to return
   * @@param node The root node to look under
   * @@param tag The tag of interest
   * @@return The child nodes
   * @@throws ProjectParseException If the number of child nodes is not equal
   * to DEFAULT_EXPECTED_NUM in sentinel.model.parser.xml.XMLParser
   */
  def getNodes( node: Node, tag: String ) = {
    try {
      sentinel.model.parser.xml.XMLParser.getNodes( node, tag )
    } catch {
      case e: sentinel.model.parser.ClassParseException =>
	throw new ProjectParseException( e.getMessage )
    }
  }
d372 1
a372 2
   * Parses in a definition node.  It also parses in the language
   * definitions themselves.
a382 1
    LanguageReader.readLanguage( file, theType )
d405 1
d414 3
a416 2
  def parseProjectNode[ T <: Spreadsheet ]( project: Node,
					    spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T ) = {
d420 1
d426 2
a427 1
		      spreadsheetFactory )
d436 1
d446 2
a447 1
				        spreadsheetFactory: ( Spreadsheet, Project[ T ], Boolean ) => T ) = {
d449 3
a451 1
    parseProjectNode( contents, spreadsheetFactory )
@


1.4
log
@Refactored so that the routine used to transform
vanilla spreadsheets into a custom version is passed
as a parameter instead of being hardcoded.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.3 2011/05/25 21:54:04 kyledewey Exp kyledewey $
d9 5
d49 2
a50 2
   * to a given desired format.  Takes a spreadsheet and whether or not to
   * register the spreadsheet as a parameter
d55 1
a55 1
  def parseProject[ T <: Spreadsheet ]( file: File, spreadsheetFactory: ( Spreadsheet, Boolean ) => T ): Project[ T ]
d61 2
a62 2
   * to a given desired format.  Takes a spreadsheet and whether or not to
   * register the spreadsheet as a parameter
d67 1
a67 1
  def parseProject[ T <: Spreadsheet ]( fileName: String, spreadsheetFactory: ( Spreadsheet, Boolean ) => T ): Project[ T ] = 
d432 1
a432 1
					    spreadsheetFactory: ( Spreadsheet, Boolean ) => T ) = {
d459 1
a459 1
				        spreadsheetFactory: ( Spreadsheet, Boolean ) => T ) = {
@


1.3
log
@Added support for values instead of just variables.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.2 2011/05/25 20:16:07 kyledewey Exp kyledewey $
d9 3
d43 3
d50 1
a50 1
  def parseProject( file: File ): Project
d55 3
d62 2
a63 2
  def parseProject( fileName: String ): Project = 
    parseProject( new File( fileName ) )
d415 3
d426 2
a427 1
  def parseProjectNode( project: Node ) = {
d433 4
a436 3
    new Project( Map() ++ sheets.map( sheet => sheet.name -> sheet ),
		 definitions,
	         associations )
d442 3
d453 2
a454 1
  def parseProject( file: File ) = {
d456 1
a456 1
    parseProjectNode( contents )
@


1.2
log
@Refactored so spreadsheet variables can be passed directly
in the XML file.  Helps to decouple code from the sheet.
@
text
@d5 1
a5 1
 *     $Id: Parser.scala,v 1.1 2010/07/11 05:54:17 kyledewey Exp $
d9 4
d147 51
d206 1
a206 2
    var typeName = ""

d208 3
a210 3
      val name = getText( variable, "Name" )
      typeName = getText( variable, "Type" ) 
      val theType = ParamType.stringToParam( typeName )
a214 2
      case e: NoSuchElementException => 
	throw new ProjectParseException( "Unknown variable type: " + typeName )
d217 1
a217 1
					 typeName )
d247 4
a250 1
      factory.get.instantiate( variables )
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
 *     $Id$
d8 4
a11 1
 *      $Log$
d49 1
a49 1
  def parseProject( fileName: String ): Project = {
a50 1
  }
d143 40
a182 3
   * Parses in a replacer factory.
   * @@param replacer The factory containing replacer information
   * @@return The replacer factory associated with the node
d184 2
a185 1
   * or there is no such factory with this name
d188 2
a189 4
  def parseReplacerNode( replacer: Node ) = {
    import sentinel.model._
    val className = getText( replacer, "ClassName" )
    
d191 5
a195 1
      ReplacerFactoryManager( className )
d197 14
a210 3
      case e: NoSuchFactoryException =>
	throw new ProjectParseException( "Unknown replacer with name: " +
					 className )
d212 57
d270 10
d282 3
a284 3
   * Parses in an association node
   * @@param association The node containing association information
   * @@return A new association encapsulating the information in the
a285 12
   * @@throws ProjectParseException If required information is missing, or
   * if the class name of a replacer isn't valid
   */
  def parseAssociationNode( association: Node ) = 
    new Association( parseCellRangeNode( getNodes( association, "CellRange" ).first ),
		     parseReplacerNode( getNodes( association, "Replacer" ).first ) )
  
  /**
   * Parses in an associations node
   * @@param associations The node containing associations
   * @@return A new list of associations, encapsulating the information
   * in the node
d287 1
d289 7
a295 2
  def parseAssociationsNode( associations: Node ): Seq[ Association ] =
    ( associations \ "Association" ).map( parseAssociationNode( _ ) )
@
